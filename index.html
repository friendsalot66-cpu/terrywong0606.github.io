<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-API Chat Interface (v2.16.1)</title>

    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/showdown@2.1.0/dist/showdown.min.js" onerror="console.warn('Showdown failed to load')"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" onerror="console.warn('HighlightJS failed to load')"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" onerror="console.warn('HighlightCSS failed to load')">
    
    <!-- Mathematics (KaTeX) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" onerror="console.warn('Katex CSS failed to load')"></link>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" onerror="console.warn('Katex JS failed to load')"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onerror="console.warn('Katex AutoRender failed to load')"></script>

    <!-- Diagrams (Mermaid) -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js" onerror="console.warn('Mermaid failed to load')"></script>

    <!-- Documents (PDF.js) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" onerror="console.warn('PDF.js failed to load')"></script>
    <script>
        if(window.pdfjsLib) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
    </script>
    
    <!-- Highcharts & SheetJS Dependencies -->
    <script src="https://code.highcharts.com/highcharts.js" onerror="console.warn('Highcharts failed to load')"></script>
    <script src="https://code.highcharts.com/modules/exporting.js" onerror="console.warn('Highcharts Exporting failed to load')"></script>
    <script src="https://code.highcharts.com/modules/accessibility.js" onerror="console.warn('Highcharts Accessibility failed to load')"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" onerror="console.warn('XLSX failed to load')"></script>

    <script>
        // Immediately apply theme to avoid flash
        try {
            const theme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-color-scheme', theme);
        } catch(e) {}
    </script>

    <!-- Embedded CSS -->
    <style>
:root {
  /* Primitive Color Tokens */
  --color-white: rgba(255, 255, 255, 1);
  --color-black: rgba(0, 0, 0, 1);
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-gray-300: rgba(167, 169, 169, 1);
  --color-gray-400: rgba(119, 124, 124, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-400: rgba(45, 166, 178, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-teal-700: rgba(26, 104, 115, 1);
  --color-teal-800: rgba(41, 150, 161, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-orange-400: rgba(230, 129, 97, 1);
  --color-orange-500: rgba(168, 75, 47, 1);

  /* RGB versions */
  --color-brown-600-rgb: 94, 82, 64;
  --color-teal-500-rgb: 33, 128, 141;
  --color-slate-900-rgb: 19, 52, 59;
  --color-slate-500-rgb: 98, 108, 113;
  --color-red-500-rgb: 192, 21, 47;

  /* Background color tokens */
  --color-bg-1: rgba(59, 130, 246, 0.08); 
  --color-bg-2: rgba(245, 158, 11, 0.08); 
  --color-bg-3: rgba(33, 201, 151, 0.1); /* Success Light */
  --color-bg-4: rgba(220, 53, 69, 0.1); /* Error Light */

  /* Semantic Color Tokens (Light Mode) */
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-text-secondary: var(--color-slate-500);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-primary-active: var(--color-teal-700);
  --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
  --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
  --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
  --color-border: rgba(var(--color-brown-600-rgb), 0.2);
  --color-btn-primary-text: var(--color-cream-50);
  --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
  --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
  --color-error: var(--color-red-500);
  --color-success: var(--color-teal-500);
  --color-warning: var(--color-orange-500);
  --color-info: var(--color-slate-500);
  --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
  --color-tab-bg: #e4e6ea;
  --color-tab-active: var(--color-background);
  --color-tab-hover: #d8dbe0;

  /* Common style patterns */
  --focus-ring: 0 0 0 3px var(--color-focus-ring);
  --focus-outline: 2px solid var(--color-primary);
  --radius-sm: 6px;
  --radius-base: 8px;
  --radius-lg: 12px;

  /* Animation */
  --duration-fast: 150ms;
  --duration-normal: 250ms;
  --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

  /* Typography */
  --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  --font-size-xs: 11px;
  --font-size-sm: 12px;
  --font-size-base: 14px;
  
  /* Spacing */
  --space-4: 4px;
  --space-8: 8px;
  --space-12: 12px;
  --space-16: 16px;
  --space-20: 20px;

  /* Shadows */
  --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
}

/* Dark mode colors */
html[data-color-scheme="dark"] {
    --color-gray-400-rgb: 119, 124, 124;
    --color-teal-300-rgb: 50, 184, 198;
    --color-gray-300-rgb: 167, 169, 169;
    --color-gray-200-rgb: 245, 245, 245;

    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
    --color-primary: var(--color-teal-300);
    --color-primary-hover: var(--color-teal-400);
    --color-primary-active: var(--color-teal-800);
    --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
    --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
    --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
    --color-border: rgba(var(--color-gray-400-rgb), 0.3);
    --color-btn-primary-text: var(--color-slate-900);
    --color-card-border: rgba(var(--color-gray-400-rgb), 0.15);
    --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
    --color-tab-bg: #2d3032;
    --color-tab-active: var(--color-background);
    --color-tab-hover: #383b3d;
}

/* Base styles */
html { font-size: var(--font-size-base); font-family: var(--font-family-base); color: var(--color-text); background-color: var(--color-background); box-sizing: border-box; }
body { margin: 0; padding: 0; }
*, *::before, *::after { box-sizing: inherit; }
.hidden { display: none !important; }

/* Buttons */
.btn { display: inline-flex; align-items: center; justify-content: center; padding: var(--space-8) var(--space-16); border-radius: var(--radius-base); font-size: var(--font-size-base); font-weight: 500; cursor: pointer; transition: all var(--duration-fast); border: none; }
.btn--primary { background: var(--color-primary); color: var(--color-btn-primary-text); }
.btn--primary:hover { background: var(--color-primary-hover); }
.btn--secondary { background: var(--color-secondary); color: var(--color-text); }
.btn--secondary:hover { background: var(--color-secondary-hover); }
.btn--sm { padding: var(--space-4) var(--space-12); font-size: var(--font-size-sm); border-radius: var(--radius-sm); }
.btn--text { background: transparent; color: var(--color-primary); padding: 4px 8px; }
.btn--text:hover { background: var(--color-secondary); }

/* Forms */
.form-control { display: block; width: 100%; padding: var(--space-8) var(--space-12); font-size: var(--font-size-base); color: var(--color-text); background-color: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); }
.form-control:focus { outline: 2px solid var(--color-primary); border-color: transparent; }
.form-label { display: block; margin-bottom: var(--space-8); font-size: var(--font-size-sm); font-weight: 500; }
.form-group { margin-bottom: var(--space-16); }

/* App Layout */
.app-container { display: flex; height: 100vh; background-color: var(--color-background); }

/* Sidebar */
.sidebar { 
    width: 42px; 
    min-width: 42px; 
    flex-shrink: 0; 
    background-color: var(--color-surface); 
    border-right: 1px solid var(--color-border); 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    padding: 56px 0 8px 0; 
    gap: var(--space-12); 
    z-index: 100;
    transition: transform 0.3s ease;
}
.sidebar-icon { 
    width: 32px; 
    height: 32px; 
    font-size: 18px; 
    border-radius: var(--radius-sm); 
    background-color: var(--color-secondary); 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    cursor: pointer; 
    border: 1px solid var(--color-border); 
}
.sidebar-icon:hover { background-color: var(--color-secondary-hover); transform: translateY(-1px); }
.sidebar-icon.active { background-color: var(--color-primary); color: var(--color-btn-primary-text); border-color: var(--color-primary); }
.sidebar-icon .icon { font-size: 18px; }

/* Main Content */
.main-content { flex: 1; display: flex; flex-direction: column; min-width: 0; background-color: var(--color-background); }

/* Header */
.header {
  background: var(--color-surface);
  border-bottom: 1px solid var(--color-border);
  padding: 8px 16px;
  display: flex;
  justify-content: space-between; 
  align-items: center;
  min-height: 40px;
}
.header-left { display: flex; align-items: center; gap: 8px; }
.mobile-menu-btn { display: none; background: none; border: none; font-size: 18px; cursor: pointer; color: var(--color-text); padding: 4px; }
.header-info h1 { font-size: 14px; font-weight: 600; margin: 0; color: var(--color-text); }
.header-info small { opacity: 0.7; margin-left: 6px; font-weight: 400; font-size: 10px; } /* Explicit 10px font size */
.status-line { display: flex; align-items: center; gap: 8px; font-size: 11px; color: var(--color-text-secondary); margin-top: 2px; }
.header-right { display: flex; align-items: center; gap: 8px; }
.header-icon { 
    background: none; border: none; cursor: pointer; color: var(--color-text-secondary); 
    font-size: 18px; width: 28px; height: 28px; border-radius: 4px; display: flex; align-items: center; justify-content: center;
    opacity: 0.6; transition: opacity 0.2s;
}
.header-icon:hover { color: var(--color-primary); background: var(--color-secondary); opacity: 1; }

/* Status Notification (Right Side) */
.status {
  display: none; align-items: center; padding: 4px 10px; border-radius: var(--radius-sm);
  font-size: 11px; font-weight: 500; white-space: nowrap; margin-left: auto;
}
.status.show { display: inline-flex !important; animation: fadeIn 0.2s; }
.status--success { background-color: var(--color-bg-3); color: var(--color-success); border: 1px solid var(--color-success); }
.status--error { background-color: var(--color-bg-4); color: var(--color-error); border: 1px solid var(--color-error); }
.status--info { background-color: var(--color-secondary); color: var(--color-text); border: 1px solid var(--color-border); }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

/* Tabs */
.tabs-container { 
    display: flex; 
    background-color: transparent; 
    padding: 4px 8px 6px; /* Added bottom padding for scrollbar */
    overflow-x: auto; 
    overflow-y: hidden; /* Prevent vertical scroll */
    flex-wrap: nowrap; /* Force single row */
    height: 40px; /* Increased height to accommodate scrollbar */
    align-items: flex-end; 
    border-bottom: 1px solid var(--color-border);
    /* Custom Scrollbar for Firefox */
    scrollbar-width: thin; 
    scrollbar-color: var(--color-border) transparent;
}
/* Custom Scrollbar for Webkit (Edge, Chrome, Safari) */
.tabs-container::-webkit-scrollbar { height: 4px !important; }
.tabs-container::-webkit-scrollbar-track { background: transparent; }
.tabs-container::-webkit-scrollbar-thumb { background-color: var(--color-border); border-radius: 4px; }
.tabs-container::-webkit-scrollbar-thumb:hover { background-color: var(--color-text-secondary); }

.tab { 
    display: flex; 
    align-items: center; 
    padding: 0 12px; 
    cursor: pointer; 
    background: var(--color-tab-bg); 
    border: 1px solid var(--color-border); 
    border-bottom: none; 
    border-radius: 6px 6px 0 0; 
    font-size: 12px; 
    color: var(--color-text-secondary); 
    min-width: 80px; 
    max-width: 200px; 
    height: 28px; 
    margin-right: 4px; 
    user-select: none;
    flex-shrink: 0; /* Prevent squishing */
}
.tab.active { background-color: var(--color-background); color: var(--color-text); font-weight: 600; height: 30px; border-top: 2px solid var(--color-primary); margin-bottom: -1px; z-index: 1; }
.tab-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex: 1; margin-right: 4px; }
.tab-close { opacity: 0.5; font-size: 14px; width: 16px; height: 16px; display: flex; align-items: center; justify-content: center; border-radius: 50%; }
.tab-close:hover { opacity: 1; background-color: var(--color-error); color: white; }
.tab-edit { opacity: 0; font-size: 10px; margin: 0 4px; }
.tab:hover .tab-edit { opacity: 0.5; }
.tab-name-input { border: none; background: transparent; width: 100%; font-size: inherit; outline: 2px solid var(--color-primary); color: var(--color-text); }
.tab-add-btn { min-width: 32px; max-width: 32px; padding: 0; justify-content: center; color: var(--color-text-secondary); font-size: 18px; font-weight: bold; }
.tab-add-btn:hover { background: var(--color-secondary); color: var(--color-primary); }

/* Chat Area */
.chat-wrapper { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
.chat-container { flex: 1; overflow-y: auto; padding: 16px; }
.messages-wrapper { max-width: 800px; margin: 0 auto; width: 100%; }
.messages { display: flex; flex-direction: column; gap: 12px; padding-bottom: 40px; }

.message { background-color: var(--color-surface); border-radius: var(--radius-lg); padding: 12px; border: 1px solid var(--color-card-border); position: relative; }
.message.user { background-color: var(--color-bg-1); border-color: rgba(var(--color-primary), 0.2); }
.message-header { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 11px; color: var(--color-text-secondary); text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px; }
.message-content { font-size: 14px; line-height: 1.6; color: var(--color-text); }
.message-image { max-width: 100%; border-radius: var(--radius-base); margin-top: 8px; border: 1px solid var(--color-border); }

/* Thinking Block */
.thinking-details {
    border-left: 3px solid var(--color-primary);
    background-color: var(--color-bg-1);
    padding: 8px 12px;
    margin-bottom: 12px;
    border-radius: 4px;
    font-size: 0.9em;
    color: var(--color-text-secondary);
}
.thinking-details summary { cursor: pointer; font-weight: 500; opacity: 0.8; margin-bottom: 4px; outline: none; }
.thinking-content { margin-top: 8px; opacity: 0.9; }

/* Mermaid & Math */
.mermaid { text-align: center; margin: 12px 0; background: var(--color-surface); padding: 8px; border-radius: 4px; overflow-x: auto; }
.katex { font-size: 1.1em; }

/* Floating Message Buttons (Export/Fork) */
.message-export-btn {
    position: absolute;
    bottom: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s, background 0.2s, color 0.2s;
    font-size: 12px;
    z-index: 5;
    box-shadow: var(--shadow-sm);
}
.message-fork-btn {
    position: absolute;
    bottom: 8px;
    right: 40px; /* Positioned to the left of export button */
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s, background 0.2s, color 0.2s;
    font-size: 12px;
    z-index: 5;
    box-shadow: var(--shadow-sm);
}
.message:hover .message-export-btn, .message:hover .message-fork-btn { opacity: 1; }
.message-export-btn:hover, .message-fork-btn:hover { background: var(--color-secondary); color: var(--color-primary); border-color: var(--color-primary); }

/* Token Info Icon & Tooltip */
.token-info-icon {
    position: absolute;
    bottom: 8px;
    left: 8px;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    font-size: 11px;
    font-weight: bold;
    display: flex; align-items: center; justify-content: center;
    cursor: help;
    opacity: 0.7;
    z-index: 5;
}
.token-info-icon:hover { opacity: 1; border-color: var(--color-primary); color: var(--color-primary); background: var(--color-bg-1); }

.token-tooltip {
    visibility: hidden;
    background-color: var(--color-surface);
    color: var(--color-text);
    text-align: left;
    border-radius: 6px;
    padding: 8px 12px;
    position: absolute;
    z-index: 20;
    bottom: 24px;
    left: 0;
    border: 1px solid var(--color-primary);
    box-shadow: var(--shadow-md);
    font-size: 11px;
    line-height: 1.4;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
}
.token-info-icon:hover .token-tooltip {
    visibility: visible;
    opacity: 1;
}

.msg-actions { display: flex; gap: 4px; }
.msg-btn { background: none; border: none; cursor: pointer; font-size: 14px; opacity: 0.6; padding: 2px; }
.msg-btn:hover { opacity: 1; color: var(--color-primary); }

/* Input Area Consolidated */
.input-area { 
    border-top: 1px solid var(--color-border); 
    background-color: var(--color-surface); 
    padding: 6px 12px; 
    position: relative; 
}
.input-wrapper { 
    display: flex; 
    flex-direction: column;
    background-color: var(--color-background); 
    border: 1px solid var(--color-border); 
    border-radius: var(--radius-lg); 
    padding: 8px 12px; 
    transition: border-color 0.2s; 
}
.input-wrapper:focus-within { border-color: var(--color-primary); }
#messageInput { 
    border: none; outline: none; background: transparent; resize: none; 
    max-height: 150px; font-family: inherit; font-size: 14px; color: var(--color-text); 
    width: 100%; margin-bottom: 4px; padding-bottom: 4px; /* Ensure content isn't cut off */
    line-height: 1.5;
}
.input-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 4px; }
.left-tools { display: flex; gap: 8px; }

.send-btn { width: 28px; height: 28px; border-radius: 6px; background: var(--color-primary); color: white; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
.send-btn.stop { background: var(--color-error); }
.action-btn { 
    background: none; border: none; cursor: pointer; font-size: 14px; 
    color: var(--color-text-secondary); opacity: 0.8; transition: all 0.2s; 
    padding: 4px;
}
.action-btn:hover { color: var(--color-primary); opacity: 1; background: var(--color-secondary); border-radius: 4px; }

/* Token Counter */
.token-est { font-size: 10px; color: var(--color-text-secondary); margin-right: 8px; opacity: 0.7; }

/* FAB */
.fab-area { position: absolute; bottom: 20px; right: 24px; pointer-events: none; z-index: 20; }
.fab-btn { 
    width: 32px; height: 32px; 
    border-radius: 50%; background: var(--color-surface); color: var(--color-text-secondary); 
    border: 1px solid var(--color-border); box-shadow: var(--shadow-sm); 
    font-size: 16px; cursor: pointer; pointer-events: auto; opacity: 0.6; 
    transition: all 0.2s; display: flex; align-items: center; justify-content: center; 
}
.fab-area:hover .fab-btn, .fab-btn:hover { opacity: 1; background: var(--color-error); color: white; border-color: var(--color-error); }
/* FAB CONFIRM STATE */
.fab-btn.confirm-state { 
    background: rgba(220, 53, 69, 0.6); 
    color: white; opacity: 1; 
    border-color: var(--color-error); 
    animation: pulse 0.5s; 
    font-size: 14px; /* Smaller X */
}
@keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

/* Code Block Buttons */
.code-copy-btn {
    background: transparent; border: 1px solid rgba(255,255,255,0.2);
    color: rgba(255,255,255,0.7); font-size: 10px; padding: 2px 6px;
    border-radius: 4px; cursor: pointer; transition: all 0.2s;
}
.code-copy-btn:hover { background: rgba(255,255,255,0.1); color: white; }
.code-copy-btn.success { border-color: var(--color-success); color: var(--color-success); background: var(--color-bg-3); }

/* Popups & Drawer */
.popup { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
.popup-content { background: var(--color-surface); padding: 24px; border-radius: var(--radius-lg); width: 100%; max-width: 450px; max-height: 85vh; overflow-y: auto; box-shadow: var(--shadow-md); border: 1px solid var(--color-border); }
.popup-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--color-border); padding-bottom: 12px; margin-bottom: 16px; }
.popup-header h3 { margin: 0; font-size: 18px; color: var(--color-text); }
.popup.hidden { display: none; }

/* Drawer for History */
#historyPopup { justify-content: flex-start; }
#historyPopup .popup-content {
    height: 100%; max-height: 100%; border-radius: 0; width: 300px; max-width: 80vw;
    margin: 0; animation: slideInLeft 0.3s;
}
@keyframes slideInLeft { from { transform: translateX(-100%); } to { transform: translateX(0); } }

/* History List Styling */
.history-item { 
    display: flex; align-items: center; justify-content: space-between; 
    padding: 10px; border-radius: 6px; cursor: pointer; transition: background 0.2s; 
    border: 1px solid transparent; position: relative;
}
.history-item:hover { background-color: var(--color-secondary); border-color: var(--color-border); }
.history-name { flex: 1; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; font-size: 13px; font-weight: 500; color: var(--color-text); }

/* Replaced Dropdown with Inline Actions */
.history-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s; }
.history-item:hover .history-actions { opacity: 1; }
@media (hover: none) { .history-actions { opacity: 1; } }

.history-action-btn {
    background: transparent; border: none; cursor: pointer;
    font-size: 14px; padding: 4px; color: var(--color-text-secondary);
    border-radius: 4px;
    display: flex; align-items: center; justify-content: center;
}
.history-action-btn:hover { background-color: var(--color-bg-1); color: var(--color-primary); }
.history-action-btn.delete:hover { color: var(--color-error); background-color: var(--color-bg-4); }

/* Settings */
.toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; }
.toggle-switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; inset: 0; background-color: var(--color-secondary-active); transition: .4s; border-radius: 24px; }
.slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .slider { background-color: var(--color-primary); }
input:checked + .slider:before { transform: translateX(20px); }
.settings-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; font-weight: 500; }

/* Tables & Markdown */
.table-responsive { overflow-x: auto; margin: 12px 0; border: 1px solid var(--color-border); border-radius: var(--radius-base); }
table { width: 100%; border-collapse: collapse; font-size: 13px; }
th, td { padding: 8px 12px; border-bottom: 1px solid var(--color-border); text-align: left; }
th { background-color: var(--color-secondary); font-weight: 600; }
.table-actions { display: flex; gap: 8px; padding: 4px; background: var(--color-secondary); justify-content: flex-end; }
pre { background: var(--color-secondary); padding: 12px; border-radius: 6px; overflow-x: auto; font-family: var(--font-family-mono); font-size: 12px; border: 1px solid var(--color-border); margin: 8px 0; }
.code-header { display: flex; justify-content: space-between; padding: 4px 8px; background: var(--color-secondary-active); font-size: 11px; border-radius: 6px 6px 0 0; }
.reference-link { color: var(--color-primary); cursor: pointer; font-size: 0.9em; margin: 0 2px; }
.reference-link:hover { text-decoration: underline; }
.theme-options, .persona-options, .model-options { display: flex; flex-direction: column; gap: 8px; }
.theme-option, .persona-option, .model-option { padding: 8px 12px; border: 1px solid var(--color-border); background-color: var(--color-surface); border-radius: 8px; cursor: pointer; text-align: left; font-size: 12px; color: var(--color-text); display: flex; align-items: center; gap: 8px; justify-content: space-between; }
.theme-option:hover, .persona-option:hover, .model-option:hover { background-color: var(--color-secondary); }
.theme-option.active, .persona-option.active, .model-option.active { background-color: var(--color-primary); color: var(--color-btn-primary-text); border-color: var(--color-primary); }
.msg-edit-area { margin-top: 8px; }
.msg-edit-textarea { width: 100%; min-height: 80px; padding: 8px; border: 1px solid var(--color-primary); border-radius: var(--radius-base); font-family: inherit; font-size: inherit; background: var(--color-background); color: var(--color-text); resize: vertical; margin-bottom: 8px; }
.msg-edit-controls { display: flex; gap: 8px; justify-content: flex-end; }
.partial-mode-container { margin-bottom: 8px; background: var(--color-bg-1); border: 1px solid var(--color-primary); border-radius: 8px; padding: 8px; }
.prefill-label { font-size: 11px; color: var(--color-primary); font-weight: 600; display: block; margin-bottom: 4px; }
#prefillInput { width: 100%; border: none; background: transparent; font-size: 13px; color: var(--color-text); outline: none; resize: none; min-height: 40px; }
.image-preview { margin-bottom: 8px; border: 1px solid var(--color-border); padding: 8px; border-radius: 8px; display: flex; gap: 8px; align-items: center; font-size: 12px; color: var(--color-text-secondary); background: var(--color-bg-1); }
.preview-image { max-height: 80px; border-radius: 4px; }
.file-preview-icon { font-size: 24px; margin-right: 4px; }
.remove-image-btn { margin-left: auto; cursor: pointer; color: var(--color-error); font-weight: bold; padding: 4px; }
input[type=range] { width: 100%; } /* Fix slider width */

/* Custom Prompt Textarea Fix */
#customPrompt {
    font-family: var(--font-family-base); /* Align font with app */
    font-size: 13px;
    line-height: 1.5;
    min-height: 80px;
    max-height: 300px;
    resize: vertical;
    overflow-y: auto; /* Ensure vertical scrolling */
}

/* Readme / About Popup Styles */
.feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; margin: 16px 0; }
.feature-card { background-color: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-base); padding: 12px; transition: transform 0.2s; cursor: pointer; }
.feature-card:hover { border-color: var(--color-primary); background-color: var(--color-bg-1); }
.feature-icon { font-size: 20px; margin-bottom: 8px; }
.feature-title { font-weight: 600; margin-bottom: 4px; color: var(--color-text); font-size: 13px; }
.feature-desc { font-size: 12px; color: var(--color-text-secondary); margin: 0; line-height: 1.4; }
.key-section { background-color: var(--color-bg-1); border: 1px solid var(--color-primary); border-radius: var(--radius-base); padding: 16px; margin: 16px 0; }
.readme-footer { margin-top: 24px; padding-top: 12px; border-top: 1px solid var(--color-border); text-align: center; color: var(--color-text-secondary); font-size: 11px; }

/* Readme Details View */
.feature-detail-view { display: none; animation: fadeIn 0.3s; }
.feature-detail-view.active { display: block; }
.detail-header { display: flex; align-items: center; gap: 12px; margin-bottom: 16px; border-bottom: 1px solid var(--color-border); padding-bottom: 12px; }
.back-btn { background: none; border: none; font-size: 18px; cursor: pointer; color: var(--color-primary); padding: 4px; }
.detail-content h4 { margin-top: 0; color: var(--color-text); }
.detail-content p, .detail-content li { font-size: 13px; color: var(--color-text); line-height: 1.5; }
.detail-content code { background: var(--color-secondary); padding: 2px 4px; border-radius: 4px; font-family: var(--font-family-mono); font-size: 0.9em; }

/* Workspace Status */
.workspace-status { font-size: 11px; color: var(--color-text-secondary); margin-bottom: 8px; padding: 4px 8px; background: var(--color-bg-1); border-radius: 4px; display: flex; justify-content: space-between; align-items: center; }

@media (max-width: 768px) {
    .sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 64px; transform: translateX(-100%); transition: transform 0.3s; box-shadow: var(--shadow-md); }
    .sidebar.open { transform: translateX(0); }
    .main-content { margin-left: 0; width: 100%; }
    .header { padding: 8px 12px; }
    .mobile-menu-btn { display: block; }
    .popup-content { width: 90%; max-height: 90vh; }
}
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-icon" id="settingsToggle" title="Settings"><span class="icon">‚öôÔ∏è</span></div>
            <div class="sidebar-icon" id="personaToggle" title="Persona"><span class="icon">üë§</span></div>
            <div class="sidebar-icon" id="oneShotToggle" title="One-shot Mode"><span class="icon">üî•</span></div>
            <div class="sidebar-icon" id="feedbackToggle" title="Feedback Loop"><span class="icon">üîÅ</span></div>
            <div class="sidebar-icon" id="refToggle" title="Toggle References"><span class="icon">üîó</span></div>
            <div class="sidebar-icon" id="toolsToggle" title="Local Tools"><span class="icon">üõ†Ô∏è</span></div>
            <div class="sidebar-icon" id="historyToggle" title="History"><span class="icon">üìÇ</span></div>
            <div class="sidebar-icon" id="apiKeyToggle" title="API Keys"><span class="icon">üîë</span></div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Header -->
            <div class="header" id="header">
                <div class="header-left">
                    <button class="mobile-menu-btn" id="mobileMenuBtn">‚ò∞</button>
                    <div class="header-info">
                        <h1>Multi-API Chat Interface<small>v2.16.1</small></h1>
                        <div class="status-line">
                            <span id="modelStatus">Model: Sonar</span>
                            <span>|</span>
                            <span id="personaStatus">Persona: All-rounder</span>
                            <span id="saveStatus" style="opacity: 0; transition: opacity 0.5s; color: var(--color-success); margin-left: 8px; font-weight: bold;">Saved</span>
                        </div>
                    </div>
                </div>
                <!-- Right Side: Status & About -->
                <div class="header-right">
                    <div class="status hidden" id="statusIndicator"></div>
                    <button class="header-icon hidden" id="openInNewTab" title="Open Full App (Fix Storage)" style="color:var(--color-primary); background:var(--color-bg-1);">‚Üó</button>
                    <button class="header-icon" id="readmeToggle" title="About">‚ÑπÔ∏è</button>
                </div>
            </div>

            <!-- Tabs -->
            <div class="tabs-container" id="tabsBar"></div>

            <!-- Chat -->
            <div class="chat-wrapper">
                <div class="chat-container" id="chatContainer">
                    <div class="messages-wrapper">
                        <div class="messages" id="messages"></div>
                    </div>
                </div>

                <!-- FAB: Clear Chat (Lower corner) -->
                <div class="fab-area">
                    <button class="fab-btn" id="clearChatBtn" title="Clear Current Chat">üóëÔ∏è</button>
                </div>
            </div>

            <!-- Input Area -->
            <div class="input-area">
                <div class="input-wrapper">
                    <div id="imagePreview" class="image-preview hidden"></div>
                    <div id="partialModeContainer" class="partial-mode-container hidden">
                        <span class="prefill-label">Partial / Prefill Mode:</span>
                        <textarea id="prefillInput" placeholder="Start the assistant's response..."></textarea>
                    </div>
                    
                    <textarea id="messageInput" placeholder="Type your message..." rows="1"></textarea>
                    
                    <div class="input-footer">
                        <div class="left-tools">
                             <button class="action-btn hidden" id="togglePartialMode" title="Partial Mode">üìù</button>
                            <button class="action-btn" id="manualImageInput" title="Image URL">üì•</button>
                            <button class="action-btn" id="imageUpload" title="Upload Image/File" onclick="document.getElementById('fileInput').click()">üìé</button>
                            <button class="action-btn" id="modelToggle" title="Change Model">üß†</button>
                        </div>
                        <div style="display:flex; align-items:center;">
                            <span id="tokenEst" class="token-est hidden">~0 toks</span>
                            <button class="send-btn" id="sendMessage" title="Send">‚Üí</button>
                        </div>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="image/*,.pdf,.txt,.md,.csv,.json,.py,.js,.html" style="display: none;">
                <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;">
            </div>
        </div>
    </div>

    <!-- Selection Tooltip -->
    <button class="selection-tooltip hidden" id="selectionTooltip" style="position: absolute; z-index: 1000; padding: 4px 8px; background: var(--color-surface); border: 1px solid var(--color-primary); border-radius: 4px; cursor: pointer;">‚úèÔ∏è Improve</button>

    <!-- Popups -->
    <div class="popup hidden" id="settingsPopup">
        <div class="popup-content">
            <div class="popup-header">
                <h3>Settings</h3>
                <button class="btn btn--text" onclick="document.getElementById('settingsPopup').classList.add('hidden')">Done</button>
            </div>
            <div class="settings-row">
                <span>Dark Mode</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="themeToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="settings-row">
                <span>Streaming Responses</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="streamToggle">
                    <span class="slider"></span>
                </label>
            </div>
            
            <h4 style="margin-top:20px; border-top:1px solid var(--color-border); padding-top:12px;">Storage & Data Rescue</h4>
            <p style="font-size:11px; color:var(--color-text-secondary);">If chats disappear due to restricted iframe access:</p>
            <div style="display:flex; gap:8px;">
                <button id="runStorageDoctorBtn" class="btn btn--secondary btn--sm" style="flex:1;">üè• Run Doctor</button>
                <button id="reqStorageAccessBtn" class="btn btn--primary btn--sm hidden" style="flex:1;">üîë Connect Database</button>
            </div>
            <div id="storageDoctorResult" style="margin-top:8px; font-size:12px; padding:8px; background:var(--color-bg-1); border-radius:4px; display:none;"></div>
        </div>
    </div>

    <div class="popup hidden" id="personaPopup">
        <div class="popup-content">
            <div class="popup-header">
                <h3>Choose Persona</h3>
                <button class="btn btn--text" onclick="document.getElementById('personaPopup').classList.add('hidden')">OK</button>
            </div>
            <div class="persona-options">
                <button class="persona-option" data-persona="allrounder"><span>üéØ</span> All-rounder</button>
                <button class="persona-option" data-persona="excel"><span>üìä</span> Excel Specialist</button>
                <button class="persona-option" data-persona="grammar"><span>üìù</span> Grammar checker</button>
                <button class="persona-option" data-persona="auditor"><span>üîç</span> Auditor</button>
                <button class="persona-option" data-persona="customized"><span>‚öôÔ∏è</span> Custom / Create</button>
            </div>
            <h4 style="margin-top:16px; margin-bottom:8px; font-size:11px; color:var(--color-text-secondary); text-transform:uppercase;">Saved Personas</h4>
            <div class="persona-options" id="savedPersonasContainer"></div>
            
            <div style="display:flex; gap:8px; margin-top:8px; border-top:1px solid var(--color-border); padding-top:8px;">
               <button id="exportPersonasBtn" class="btn btn--secondary btn--sm" style="flex:1;">Export Personas</button>
               <button id="importPersonasBtn" class="btn btn--secondary btn--sm" style="flex:1;">Import Personas</button>
               <input type="file" id="importPersonasInput" accept=".json" style="display:none">
            </div>
            
            <div class="custom-prompt-section hidden" id="customPromptSection" style="margin-top:16px; padding-top:16px; border-top:1px solid var(--color-border);">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <h4 style="font-size:14px; margin:0;">Edit Persona</h4>
                </div>
                <label class="form-label">Name:</label>
                <input type="text" id="customPersonaName" class="form-control" placeholder="e.g. Python Expert" style="margin-bottom: 8px;">
                <label class="form-label">System Prompt:</label>
                <textarea id="customPrompt" class="form-control" placeholder="Enter system prompt..." rows="3"></textarea>
                <div class="form-group" style="margin-top: 8px; display: flex; gap: 8px;">
                    <button class="btn btn--primary btn--sm" id="saveCustomPrompt" style="flex:1;">Update / Apply</button>
                    <button class="btn btn--secondary btn--sm" id="saveAsNewPersona" style="flex:1;">Save as New</button>
                </div>
            </div>
        </div>
    </div>

    <div class="popup hidden" id="modelPopup">
        <div class="popup-content">
            <div class="popup-header">
                <h3>Model & Settings</h3>
                <button class="btn btn--text" onclick="document.getElementById('modelPopup').classList.add('hidden')">OK</button>
            </div>
            <div class="form-group">
                <label class="form-label">Max Tokens: <span id="maxTokensValue">4096</span></label>
                <input type="range" id="maxTokensSlider" min="100" max="8000" step="100" value="4096">
                <input type="number" id="maxTokensInput" class="form-control" style="width: 100%; margin-top: 4px;" value="4096">
            </div>
            <h4 style="margin-top:16px;">Perplexity</h4>
            <div class="model-options">
                <div class="settings-row" style="padding: 4px 0; border-bottom: 1px solid var(--color-border); margin-bottom: 8px;">
                    <span>Enable Web Search</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="pplxSearchToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="settings-row" style="margin-top:8px; border-bottom:1px solid var(--color-border); padding-bottom:8px;">
                     <div style="display:flex; align-items:center; gap:4px;">
                         <span>Recency Filter</span>
                         <span id="recencyInfoIcon" title="Month, Week, and Day use the native Perplexity API filter. Year and Custom Range use System Prompts to guide the model." style="cursor:pointer; font-size:12px; opacity:0.7;">‚ìò</span>
                     </div>
                     <select id="pplxRecencySelect" class="form-control" style="width:120px; padding:2px;">
                         <option value="">Any Time</option>
                         <option value="month">Month</option>
                         <option value="week">Week</option>
                         <option value="day">Day</option>
                         <option value="year">Year</option>
                         <option value="custom">Custom Range</option>
                     </select>
                </div>
                <div id="pplxCustomDateContainer" class="hidden" style="margin-top:8px; display:flex; gap:4px; align-items:center;">
                    <input type="date" id="pplxStartDate" class="form-control" style="font-size:11px; padding:4px;">
                    <span>to</span>
                    <input type="date" id="pplxEndDate" class="form-control" style="font-size:11px; padding:4px;">
                </div>
                <button class="model-option" data-model="sonar" data-api="perplexity"><span>üîç</span> Sonar</button>
                <button class="model-option" data-model="sonar-pro" data-api="perplexity"><span>üîç</span> Sonar Pro</button>
                <button class="model-option" data-model="sonar-reasoning-pro" data-api="perplexity"><span>üß†</span> Sonar Reasoning Pro</button>
                <button class="model-option" data-model="sonar-deep-research" data-api="perplexity"><span>üìö</span> Sonar Deep Research</button>
            </div>
            <h4 style="margin-top:16px;">Moonshot</h4>
            <div class="model-options">
                <button class="model-option" data-model="kimi-k2-0905-preview" data-api="moonshot"><span>üöÄ</span> Kimi k2 (Preview)</button>
                <button class="model-option" data-model="kimi-k2-turbo-preview" data-api="moonshot"><span>üöÄ</span> Kimi k2 Turbo</button>
                <button class="model-option" data-model="kimi-k2-thinking" data-api="moonshot"><span>üß†</span> Kimi k2 Thinking</button>
                <button class="model-option" data-model="kimi-k2-thinking-turbo" data-api="moonshot"><span>üß†</span> Kimi k2 Thinking Turbo</button>
            </div>
        </div>
    </div>

    <div class="popup hidden" id="apiKeyPopup">
        <div class="popup-content">
            <h3>API Keys</h3>
            <div class="form-group">
                <label class="form-label">Perplexity API Key:</label>
                <input type="password" id="perplexityApiKey" class="form-control">
            </div>
            <div class="form-group">
                <label class="form-label">Moonshot API Key:</label>
                <input type="password" id="moonshotApiKey" class="form-control">
            </div>
            <div class="form-group" style="display:flex; gap:8px;">
                <button class="btn btn--secondary btn--sm" id="showApiKeys">Show/Hide</button>
                <button class="btn btn--primary btn--sm" id="saveApiKeys">Save Keys</button>
            </div>
        </div>
    </div>

    <div class="popup hidden" id="readmePopup"><div class="popup-content" style="max-width: 800px;"><div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; border-bottom:1px solid var(--color-border); padding-bottom:12px;"><h3 style="margin:0; border:none; padding:0;">About Multi-API Chat</h3><button onclick="document.getElementById('readmePopup').classList.add('hidden')" style="border:none; background:none; font-size:20px; cursor:pointer;">&times;</button></div><div id="readmeMainView"><div class="key-section" style="margin-top:0;"><h4 style="margin:0 0 8px 0;">Getting Started</h4><p style="font-size:13px; margin:0 0 8px 0;">This client-side application connects directly to Perplexity and Moonshot APIs. Your keys are stored locally.</p><ul style="font-size:13px; margin:0; padding-left:20px;"><li><strong>Step 1:</strong> Obtain API keys from <a href="https://docs.perplexity.ai/" target="_blank" style="color:var(--color-primary);">Perplexity</a> or <a href="https://platform.moonshot.cn/" target="_blank" style="color:var(--color-primary);">Moonshot AI</a>.</li><li><strong>Step 2:</strong> Click the Key icon (üîë) in the sidebar to save them.</li><li><strong>Step 3:</strong> Select a model (üß†) and start chatting.</li></ul></div><h4 style="margin-top:20px;">Features (Click for Help)</h4><div class="feature-grid"><div class="feature-card" data-feature="partial"><div class="feature-title">‚ö° Partial / Prefill Mode</div><p class="feature-desc">Guide the AI's response by starting the sentence for it. Exclusive to Kimi models.</p></div><div class="feature-card" data-feature="feedback"><div class="feature-title">üîÅ Feedback Loop</div><p class="feature-desc">Teach the model your preferences by correcting its output text.</p></div><div class="feature-card" data-feature="image"><div class="feature-title">üñºÔ∏è Set Image / Vision</div><p class="feature-desc">Analyze images or use them as context for Perplexity Sonar Pro.</p></div><div class="feature-card" data-feature="viz"><div class="feature-title">üìä Charts & Diagrams</div><p class="feature-desc">Create Mermaids flowcharts, Highcharts visualizations, and Math equations.</p></div><div class="feature-card" data-feature="tools"><div class="feature-title">üõ†Ô∏è Local File Tools</div><p class="feature-desc">Securely link a local folder to read files directly into the chat context.</p></div><div class="feature-card" data-feature="branching"><div class="feature-title">üåø Branching & Forking</div><p class="feature-desc">Fork conversations to explore different outcomes without losing the original path.</p></div></div><div class="readme-footer"><p style="margin:0;">Multi-API Chat Interface v2.16.1</p></div></div><div id="readmeDetailView" class="feature-detail-view"><div class="detail-header"><button class="back-btn" id="readmeBackBtn">‚Üê</button><h3 style="margin:0; font-size:16px;" id="detailTitle">Feature Name</h3></div><div class="detail-content" id="detailContent"></div></div></div></div>
    <div class="popup hidden" id="referencePopup"><div class="popup-content"><div class="reference-header" style="display:flex; justify-content:space-between; margin-bottom:8px;"><h3 id="referenceTitle" style="margin:0;">Reference</h3><button id="closeReferencePopup" style="border:none; background:none; font-size:18px; cursor:pointer;">&times;</button></div><div class="reference-body"><p id="referenceSnippet" style="font-size:13px; color:var(--color-text); margin-bottom:8px; font-style:italic; background:var(--color-bg-1); padding:8px; border-radius:4px;"></p><p id="referenceUrl" style="word-break: break-all; font-size: 13px; color: var(--color-primary);"></p></div><div class="reference-actions" style="margin-top:12px; display:flex; gap:8px;"><button class="btn btn--secondary btn--sm" id="copyReference">Copy URL</button><button class="btn btn--primary btn--sm" id="openReference">Open Link</button></div></div></div>
    <div class="popup hidden" id="imageInputPopup"><div class="popup-content"><h3>Set Image Source</h3><div class="form-group"><textarea id="imageInputString" class="form-control" rows="5" placeholder="Paste URL or Base64 string..."></textarea></div><div class="form-group" style="display:flex; gap:8px;"><button class="btn btn--secondary btn--sm" id="cancelImageInput">Cancel</button><button class="btn btn--primary btn--sm" id="saveImageInput">Set Image</button></div></div></div>
    <div class="popup hidden" id="historyPopup">
        <div class="popup-content">
            <div class="popup-header">
                <h3 style="display:flex; align-items:center; gap:8px;">
                    Chat History 
                    <button id="importChatHeaderBtn" class="btn btn--text" style="font-size:16px; padding:2px;" title="Import Chat (.json)">üì•</button>
                </h3>
                <button class="btn btn--text" onclick="document.getElementById('historyPopup').classList.add('hidden')">Close</button>
            </div>
            <div class="form-group">
                <input type="text" id="historySearch" class="form-control" placeholder="Search chats..." style="margin-bottom:8px;">
            </div>
            <div class="history-list" id="historyList" style="flex:1; overflow-y:auto; display:flex; flex-direction:column; gap:4px; margin-bottom:16px;"></div>
            
            <input type="file" id="importSingleChatInput" accept=".json" multiple style="display: none;">
        </div>
    </div>
    <div class="popup hidden" id="toolsPopup"><div class="popup-content"><h3>My Tools</h3><div class="workspace-status" id="workspaceStatus">Workspace: Not Set</div><button class="btn btn--secondary btn--sm" onclick="window.chatApp.handleWorkspaceClick()" style="width:100%; margin-bottom:4px;">üìÇ Set Workspace Folder</button><div style="text-align: center; margin-bottom: 16px;"><button class="btn btn--text" onclick="window.chatApp.forceLegacyWorkspace()" style="font-size: 10px; color: var(--color-text-secondary); padding: 2px;">(Click here if button above fails)</button></div><div class="form-group"><input type="text" id="toolNameInput" class="form-control" placeholder="Tool Name" style="margin-bottom:4px;"><input type="text" id="toolPathInput" class="form-control" placeholder="Relative Path (e.g., config.json)" style="margin-bottom:4px;"><input type="text" id="toolDescInput" class="form-control" placeholder="Description" style="margin-bottom:4px;"><button class="btn btn--primary btn--sm" id="addToolBtn">Add Tool</button></div><div class="history-list" id="toolsList" style="display:flex; flex-direction:column; gap:8px;"></div></div></div>
    <div class="popup hidden" id="revisionPopup"><div class="popup-content"><h3>Feedback</h3><div class="form-group"><div id="revisionOriginal" style="background:var(--color-secondary); padding:8px; border-radius:6px; font-size:12px; max-height:100px; overflow-y:auto;"></div></div><div class="form-group"><textarea id="revisionInput" class="form-control" rows="5" placeholder="Revised version..."></textarea></div><div class="form-group" style="display:flex; gap:8px;"><button class="btn btn--secondary btn--sm" id="cancelRevision">Cancel</button><button class="btn btn--primary btn--sm" id="saveRevision">Learn</button></div></div></div>

    <script>
        window.onerror = function(msg, url, line) {
            console.error("App Error: " + msg + "\nLine: " + line);
        };

        class StorageManager {
            constructor() {
                this.dbName = 'MultiAPIChatDB';
                this.version = 3; // Incremented to 3 to force schema upgrade/fix
                this.db = null;
                this.ready = this.initDB();
                this.useLegacyMode = false;
                this.legacyFiles = new Map();
                this.rootHandle = null;
            }

            initDB() {
                if(!window.indexedDB) return Promise.resolve(null);
                return new Promise((resolve, reject) => {
                    // Try/Catch for iframe security errors
                    try {
                        const request = indexedDB.open(this.dbName, this.version);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('fileHandles')) {
                                db.createObjectStore('fileHandles');
                            }
                            if (!db.objectStoreNames.contains('savedChats')) {
                                const chatStore = db.createObjectStore('savedChats', { keyPath: 'id' });
                                chatStore.createIndex('name', 'name', { unique: false });
                                chatStore.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                        };
                        request.onsuccess = (event) => {
                            this.db = event.target.result;
                            resolve(this.db);
                        };
                        request.onerror = (event) => {
                            console.error("DB Open Error:", request.error);
                            reject(request.error);
                        };
                    } catch (e) {
                        console.error("Security Error opening DB (likely iframe):", e);
                        reject(e);
                    }
                });
            }
            
            async ensureStorageAccess() {
                if (document.hasStorageAccess && document.requestStorageAccess) {
                    try {
                        const hasAccess = await document.hasStorageAccess();
                        if (!hasAccess) {
                            await document.requestStorageAccess();
                            // Re-init DB after granting access
                            this.ready = this.initDB(); 
                            return true;
                        }
                    } catch (e) {
                        console.warn("Storage Access API failed", e);
                    }
                }
                return false;
            }

            // --- Chat Storage Methods ---

            async saveChat(chatObj) {
                try {
                    await this.ready;
                    if(!this.db) return;
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction('savedChats', 'readwrite');
                        const store = tx.objectStore('savedChats');
                        // Add timestamp if missing for sorting
                        if(!chatObj.timestamp) chatObj.timestamp = Date.now();
                        store.put(chatObj);
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error);
                    });
                } catch(e) { console.warn("Save skipped due to DB error"); }
            }

            async getChat(id) {
                try {
                    await this.ready;
                    if(!this.db) return null;
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction('savedChats', 'readonly');
                        const store = tx.objectStore('savedChats');
                        const req = store.get(id);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                } catch(e) { return null; }
            }

            async getAllChatsMetadata() {
                try {
                    await this.ready;
                    if(!this.db) return [];
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction('savedChats', 'readonly');
                        const store = tx.objectStore('savedChats');
                        const headers = [];
                        // Use cursor to avoid loading full message bodies (base64 images) into memory
                        const req = store.openCursor();
                        req.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor) {
                                headers.push({
                                    id: cursor.value.id,
                                    name: cursor.value.name,
                                    timestamp: cursor.value.timestamp,
                                    isPinned: cursor.value.isPinned
                                });
                                cursor.continue();
                            } else {
                                resolve(headers.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)));
                            }
                        };
                        req.onerror = () => reject(req.error);
                    });
                } catch(e) { return []; }
            }

            // Diagnostic: Fetch EVERYTHING raw
            async dumpAllChats() {
                try {
                    await this.ready;
                    if(!this.db) return [];
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction('savedChats', 'readonly');
                        const store = tx.objectStore('savedChats');
                        const req = store.getAll();
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                } catch(e) { throw e; }
            }

            async deleteChat(id) {
                try {
                    await this.ready;
                    if(!this.db) return;
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction('savedChats', 'readwrite');
                        const store = tx.objectStore('savedChats');
                        store.delete(id);
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error);
                    });
                } catch(e) { console.error(e); }
            }

            // --- File Handle Methods (Existing Logic) ---

            async saveHandle(handle) {
                try {
                    await this.ready;
                    if(!this.db) return;
                    const tx = this.db.transaction('fileHandles', 'readwrite');
                    tx.objectStore('fileHandles').put(handle, 'root');
                    return new Promise((resolve, reject) => {
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error);
                    });
                } catch (e) { console.error("Save handle failed", e); }
            }

            async loadHandle() {
                try {
                    await this.ready;
                    if(!this.db) return null;
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction('fileHandles', 'readonly');
                        const req = tx.objectStore('fileHandles').get('root');
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => reject(req.error);
                    });
                } catch (e) { return null; }
            }

            async restoreHandle() {
                try {
                    const handle = await this.loadHandle();
                    if (!handle) return null;
                    try {
                        const options = {};
                        if ((await handle.queryPermission(options)) === 'granted') {
                            this.rootHandle = handle;
                            this.useLegacyMode = false;
                            return handle.name;
                        }
                    } catch (permErr) { console.warn("Permission check failed:", permErr); }
                    return null;
                } catch (err) { return null; }
            }

            async selectRootDirectory() {
                if (typeof window.showDirectoryPicker !== 'function') return 'FALLBACK';
                try {
                    const handle = await window.showDirectoryPicker();
                    this.rootHandle = handle;
                    this.useLegacyMode = false;
                    await this.saveHandle(handle);
                    return handle.name;
                } catch (err) {
                    if (err.name === 'AbortError') return 'ABORT';
                    return 'FALLBACK';
                }
            }

            handleLegacySelection(fileList) {
                this.useLegacyMode = true;
                this.legacyFiles.clear();
                let rootName = "Folder";
                if(fileList.length > 0) {
                    const first = fileList[0].webkitRelativePath;
                    rootName = first.split('/')[0];
                    Array.from(fileList).forEach(f => {
                        const parts = f.webkitRelativePath.split('/');
                        parts.shift();
                        this.legacyFiles.set(parts.join('/'), f);
                    });
                }
                return rootName;
            }

            async readFile(relativePath) {
                if (this.useLegacyMode) {
                    const f = this.legacyFiles.get(relativePath);
                    if (!f) throw new Error("File not found in loaded folder: " + relativePath);
                    return await f.text();
                }
                if (!this.rootHandle) throw new Error("No workspace selected.");
                
                const parts = relativePath.split('/').filter(p => p.trim() !== '');
                const fileName = parts.pop();
                let currentHandle = this.rootHandle;
                
                try {
                    for (const part of parts) { currentHandle = await currentHandle.getDirectoryHandle(part); }
                    const fileHandle = await currentHandle.getFileHandle(fileName);
                    // Minimal permission check
                    try { if ((await fileHandle.queryPermission()) !== 'granted') await fileHandle.requestPermission(); } catch(e){}
                    const file = await fileHandle.getFile();
                    return await file.text();
                } catch (e) {
                    if (e.name === 'NotFoundError') throw new Error("File not found: " + relativePath);
                    throw e;
                }
            }
        }

        class MultiAPIChat {
            constructor() {
                this.storageManager = new StorageManager();
                
                this.apiKeys = {
                    perplexity: localStorage.getItem('perplexity_api_key') || '',
                    moonshot: localStorage.getItem('moonshot_api_key') || ''
                };
                this.currentModel = localStorage.getItem('currentModel') || 'sonar';
                this.currentAPI = localStorage.getItem('currentAPI') || 'perplexity';
                this.currentPersona = localStorage.getItem('currentPersona') || 'allrounder';
                this.customPrompt = localStorage.getItem('customPrompt') || '';
                this.customPersonaName = localStorage.getItem('customPersonaName') || 'Custom / Create';
                this.pplxSearchEnabled = localStorage.getItem('pplxSearchEnabled') !== 'false'; // Default true
                this.pplxRecency = localStorage.getItem('pplxRecency') || ''; // Recency filter
                
                this.isLoading = false;
                this.abortController = null; // Controller for stopping requests
                this.references = {};
                this.currentReference = { num: '', url: '', snippet: '', title: '' };
                this.oneShotMode = localStorage.getItem('oneShotMode') === 'true' || false;
                this.streamMode = localStorage.getItem('streamMode') !== 'false';
                
                this.savedChats = {}; // Now only metadata: { id: {id, name, timestamp} }
                this.maxTokens = parseInt(localStorage.getItem('maxTokens') || '4096');
                
                this.uploadedImage = null; 
                this.uploadedTextContext = null; 
                this.uploadedFileName = null; 

                this.sessions = {};
                this.activeSessionId = null;
                this.sessionCounter = 1;
                this.showReferences = localStorage.getItem('showReferences') !== 'false';
                this.localTools = JSON.parse(localStorage.getItem('localTools') || '[]');
                this.savedPersonas = JSON.parse(localStorage.getItem('saved_personas') || '{}');
                this.feedbackMode = localStorage.getItem('feedbackMode') === 'true' || false;
                this.feedbackLoops = JSON.parse(localStorage.getItem('feedback_loops') || '{}');
                this.messages = [];
                
                this.clearConfirmTimer = null; 

                // Library initialization fallback
                if (window.mermaid) { try { mermaid.initialize({ startOnLoad: false, theme: 'default' }); } catch(e) {} }
                if (typeof showdown !== 'undefined') {
                    try { this.converter = new showdown.Converter({ tables: true, strikethrough: true, tasklists: true, ghCodeBlocks: true, openLinksInNewWindow: true, emoji: true }); } 
                    catch (e) { this.converter = { makeHtml: (t) => t.replace(/\n/g, '<br>') }; }
                } else { this.converter = { makeHtml: (t) => t.replace(/\n/g, '<br>') }; }

                this.personas = {
                    allrounder: { name: "All-rounder", prompt: "You are a versatile AI assistant." },
                    excel: { name: "Excel Specialist", prompt: "You are an expert Excel Specialist." },
                    grammar: { name: "Grammar checker", prompt: "You are a professional grammar checker. Regardless of input, output only the revised text followed by a brief bulleted explanation of changes." },
                    auditor: { name: "Auditor", prompt: "You are an experienced audit specialist." },
                    customized: { name: "Custom / Create", prompt: "" }
                };
                Object.assign(this.personas, this.savedPersonas);
                this.personas.customized.name = this.customPersonaName;
                this.personas.customized.prompt = this.customPrompt;

                this.apiEndpoints = {
                    perplexity: "https://api.perplexity.ai/chat/completions",
                    moonshot: "https://api.moonshot.cn/v1/chat/completions"
                };
                
                this.featureDetails = {
                    partial: {
                        title: "Partial / Prefill Mode (Moonshot)",
                        content: "<p>This unique feature allows you to <strong>start the assistant's sentence</strong> for it. By typing into the 'Partial Mode' box, you force the AI to continue from that specific point.</p><h4>Use Cases:</h4><ul><li>Steering the tone (e.g., start with 'Sure, here is a sarcastic answer:')</li><li>Formatting output (e.g., start with '{ \"name\":')</li><li>Bypassing refusals (sometimes works by forcing a compliant start)</li></ul>"
                    },
                    feedback: {
                        title: "Feedback Loop / Learning",
                        content: "<p>When enabled (via the üîÅ icon), you can highlight text in the assistant's response and click 'Improve'.</p><p>You then provide a corrected version of that text. The system saves this correction and injects it into the system prompt for future messages in this chat, effectively 'teaching' the model your preferences for the duration of the session.</p>"
                    },
                    image: {
                        title: "Image & Vision Capabilities",
                        content: "<p>You can upload images or provide image URLs. Currently, this is optimized for <strong>Perplexity Sonar Pro</strong> and <strong>Moonshot Kimi</strong> (if supported) models.</p><p>The image is converted to Base64 and sent with your prompt. Use this for analyzing screenshots, diagrams, or photos.</p>"
                    },
                    viz: {
                        title: "Visualizations & Math",
                        content: "<p>The interface supports automatic rendering of:</p><ul><li><strong>Mermaid.js:</strong> Flowcharts, sequence diagrams, etc.</li><li><strong>Highcharts:</strong> Interactive charts from JSON data.</li><li><strong>KaTeX:</strong> Mathematical equations (LaTeX format).</li></ul><p>Ask the model to 'draw a flowchart' or 'plot a chart' to see it in action.</p>"
                    },
                    tools: {
                        title: "Local File Tools",
                        content: "<p>This is a powerful feature that lets you <strong>connect a local folder</strong> to the web app.</p><h4>How it works:</h4><ol><li>Click the 'Tools' (üõ†Ô∏è) icon.</li><li>Select a folder on your computer.</li><li>The app creates a mapping of files.</li><li>You can 'Open' a file to load its content directly into the chat context.</li></ol><p><em>Note: This runs entirely in your browser. No files are uploaded to a cloud server until you send them in a message.</em></p>"
                    },
                    branching: {
                        title: "Branching & Forking",
                        content: "<p>Hover over any assistant message to see the 'Fork' (üåø) button.</p><p>Clicking this creates a <strong>copy</strong> of the current conversation up to that point. You can then take the conversation in a completely different direction without losing the original thread.</p>"
                    }
                };

                this.initializeElements();
                this.attachEventListeners();
                this.loadTheme();
                this.renderSavedPersonas();
                this.updateUI();
                this.updateHeaderStatus();
                this.updateTokenConfigUI();
                this.updatePartialModeButton();
                this.detectIframe();
                
                // Request Persistence
                if (navigator.storage && navigator.storage.persist) {
                    navigator.storage.persist().then(granted => {
                        if (granted) console.log("Storage will not be cleared except by explicit user action");
                        else console.log("Storage may be cleared by the UA under pressure.");
                    });
                }
                
                // Initialize Async Data
                this.initData().then(() => {
                    if (Object.keys(this.sessions).length === 0) {
                        this.createNewSession();
                    }
                });
            }
            
            detectIframe() {
                if (window.self !== window.top) {
                    // Show breakout button
                    this.openInNewTabBtn.classList.remove('hidden');
                    this.showStatus("Running in embedded mode. Storage may be restricted.", "warning");
                    
                    // Show Connect Storage button in Settings if API exists
                    if (document.hasStorageAccess) {
                        this.reqStorageAccessBtn.classList.remove('hidden');
                    }
                }
            }

            async initData() {
                try {
                    // Restore Workspace
                    const wsName = await this.storageManager.restoreHandle();
                    if(wsName) document.getElementById('workspaceStatus').textContent = "Workspace: " + wsName;

                    // Migrate LocalStorage to IndexedDB if needed
                    const lsChats = localStorage.getItem('saved_chats');
                    if (lsChats) {
                        try {
                            const parsed = JSON.parse(lsChats);
                            const keys = Object.keys(parsed);
                            if (keys.length > 0) {
                                console.log("Migrating chats to IndexedDB...");
                                for (const k of keys) {
                                    await this.storageManager.saveChat(parsed[k]);
                                }
                                localStorage.removeItem('saved_chats');
                                this.showStatus('Storage Migrated', 'success');
                            }
                        } catch(e) { console.error("Migration failed", e); }
                    }

                    // Load Metadata for History List
                    const chatList = await this.storageManager.getAllChatsMetadata();
                    this.savedChats = {};
                    chatList.forEach(c => this.savedChats[c.id] = c);
                    
                    // Force refresh history UI immediately so user sees saved chats
                    this.renderChatHistory(); 
                    
                    // --- Restore Active Sessions from IndexedDB ---
                    const openIdsRaw = localStorage.getItem('openSessionIds');
                    const lastActiveId = localStorage.getItem('activeSessionId');
                    
                    let restoredCount = 0;
                    if (openIdsRaw) {
                        try {
                            const openIds = JSON.parse(openIdsRaw);
                            if (Array.isArray(openIds) && openIds.length > 0) {
                                for (const id of openIds) {
                                    const chat = await this.storageManager.getChat(id);
                                    if (chat) {
                                        this.sessions[id] = {
                                            id: chat.id,
                                            name: chat.name,
                                            messages: chat.messages || [],
                                            references: chat.references || {}
                                        };
                                        restoredCount++;
                                    }
                                }
                            }
                        } catch (e) {
                            console.error("Session restore failed", e);
                        }
                    }
                    
                    if (restoredCount > 0) {
                        // Sessions restored successfully
                        if (lastActiveId && this.sessions[lastActiveId]) {
                            this.switchSession(lastActiveId);
                        } else {
                            const firstId = Object.keys(this.sessions)[0];
                            this.switchSession(firstId);
                        }
                        this.renderTabs();
                        this.showStatus('Session Restored', 'success');
                    } else {
                        // Fallback: If LocalStorage was wiped but IndexedDB has data, load the most recent chat
                        const historyIds = Object.keys(this.savedChats);
                        if (historyIds.length > 0) {
                            // Sort by timestamp desc to get the last one
                            historyIds.sort((a, b) => (this.savedChats[b].timestamp || 0) - (this.savedChats[a].timestamp || 0));
                            const lastId = historyIds[0];
                            await this.loadChat(lastId);
                            this.showStatus('Last conversation loaded', 'info');
                        }
                    }
                } catch (err) {
                    console.error("Init Data Error:", err);
                    this.showStatus("History Load Failed (Check Storage Doctor)", "error");
                }
            }
            
            persistSessionState() {
                const openIds = Object.keys(this.sessions);
                localStorage.setItem('openSessionIds', JSON.stringify(openIds));
                localStorage.setItem('activeSessionId', this.activeSessionId || '');
            }

            initializeElements() {
                // UI Elements
                this.sidebar = document.getElementById('sidebar');
                this.mobileMenuBtn = document.getElementById('mobileMenuBtn');
                this.settingsToggle = document.getElementById('settingsToggle');
                this.personaToggle = document.getElementById('personaToggle');
                this.apiKeyToggle = document.getElementById('apiKeyToggle');
                this.oneShotToggle = document.getElementById('oneShotToggle');
                this.feedbackToggle = document.getElementById('feedbackToggle');
                this.historyToggle = document.getElementById('historyToggle');
                this.refToggle = document.getElementById('refToggle');
                this.toolsToggle = document.getElementById('toolsToggle');
                this.readmeToggle = document.getElementById('readmeToggle');

                this.header = document.getElementById('header');
                this.tabsBar = document.getElementById('tabsBar');
                this.chatContainer = document.getElementById('chatContainer');
                this.messagesContainer = document.getElementById('messages');
                this.modelStatus = document.getElementById('modelStatus');
                this.personaStatus = document.getElementById('personaStatus');
                this.messageInput = document.getElementById('messageInput');
                this.sendMessage = document.getElementById('sendMessage');
                this.imageUpload = document.getElementById('imageUpload');
                this.fileInput = document.getElementById('fileInput');
                this.folderInput = document.getElementById('folderInput');
                this.modelToggle = document.getElementById('modelToggle');
                this.togglePartialModeBtn = document.getElementById('togglePartialMode');
                this.partialModeContainer = document.getElementById('partialModeContainer');
                this.prefillInput = document.getElementById('prefillInput');
                this.manualImageInput = document.getElementById('manualImageInput');
                this.imageInputPopup = document.getElementById('imageInputPopup');
                this.imageInputString = document.getElementById('imageInputString');
                this.saveImageInputBtn = document.getElementById('saveImageInput');
                this.cancelImageInputBtn = document.getElementById('cancelImageInput');
                this.imagePreview = document.getElementById('imagePreview');
                this.statusIndicator = document.getElementById('statusIndicator');
                this.tokenEst = document.getElementById('tokenEst');
                
                // Popups
                this.settingsPopup = document.getElementById('settingsPopup');
                this.personaPopup = document.getElementById('personaPopup');
                this.modelPopup = document.getElementById('modelPopup');
                this.apiKeyPopup = document.getElementById('apiKeyPopup');
                this.referencePopup = document.getElementById('referencePopup');
                this.historyPopup = document.getElementById('historyPopup');
                this.toolsPopup = document.getElementById('toolsPopup');
                this.readmePopup = document.getElementById('readmePopup');
                this.revisionPopup = document.getElementById('revisionPopup');

                // Specific Action Elements
                this.savedPersonasContainer = document.getElementById('savedPersonasContainer');
                this.saveAsNewPersonaBtn = document.getElementById('saveAsNewPersona');
                this.selectionTooltip = document.getElementById('selectionTooltip');
                this.revisionOriginal = document.getElementById('revisionOriginal');
                this.revisionInput = document.getElementById('revisionInput');
                this.cancelRevisionBtn = document.getElementById('cancelRevision');
                this.saveRevisionBtn = document.getElementById('saveRevision');
                this.historyList = document.getElementById('historyList');
                this.historySearch = document.getElementById('historySearch');
                
                this.importSingleChatBtn = document.getElementById('importChatHeaderBtn');
                this.importSingleChatInput = document.getElementById('importSingleChatInput');

                this.addToolBtn = document.getElementById('addToolBtn');
                this.maxTokensSlider = document.getElementById('maxTokensSlider');
                this.maxTokensInput = document.getElementById('maxTokensInput');
                this.maxTokensValue = document.getElementById('maxTokensValue');
                this.themeToggle = document.getElementById('themeToggle');
                this.streamToggle = document.getElementById('streamToggle');
                this.setWorkspaceBtn = document.getElementById('setWorkspaceBtn');
                this.pplxSearchToggle = document.getElementById('pplxSearchToggle');
                this.pplxRecencySelect = document.getElementById('pplxRecencySelect');
                this.pplxCustomDateContainer = document.getElementById('pplxCustomDateContainer');
                this.pplxStartDate = document.getElementById('pplxStartDate');
                this.pplxEndDate = document.getElementById('pplxEndDate');
                
                this.clearChatBtn = document.getElementById('clearChatBtn');
                this.runStorageDoctorBtn = document.getElementById('runStorageDoctorBtn');
                
                // New Iframe Buttons
                this.openInNewTabBtn = document.getElementById('openInNewTab');
                this.reqStorageAccessBtn = document.getElementById('reqStorageAccessBtn');
                
                // Persona Export/Import Elements
                this.exportPersonasBtn = document.getElementById('exportPersonasBtn');
                this.importPersonasBtn = document.getElementById('importPersonasBtn');
                this.importPersonasInput = document.getElementById('importPersonasInput');

                // Readme Elements
                this.readmeMainView = document.getElementById('readmeMainView');
                this.readmeDetailView = document.getElementById('readmeDetailView');
                this.readmeBackBtn = document.getElementById('readmeBackBtn');
                this.detailTitle = document.getElementById('detailTitle');
                this.detailContent = document.getElementById('detailContent');
            }

            attachEventListeners() {
                this.mobileMenuBtn.addEventListener('click', () => {
                    this.sidebar.classList.toggle('open');
                });
                document.addEventListener('click', (e) => {
                    if (window.innerWidth <= 768 && 
                        this.sidebar.classList.contains('open') && 
                        !this.sidebar.contains(e.target) && 
                        e.target !== this.mobileMenuBtn) {
                        this.sidebar.classList.remove('open');
                    }
                });

                this.settingsToggle.addEventListener('click', () => this.togglePopup('settings'));
                this.personaToggle.addEventListener('click', () => this.togglePopup('persona'));
                this.apiKeyToggle.addEventListener('click', () => this.togglePopup('apiKey'));
                this.oneShotToggle.addEventListener('click', () => this.toggleOneShotMode());
                this.feedbackToggle.addEventListener('click', () => this.toggleFeedbackMode());
                this.refToggle.addEventListener('click', () => this.toggleReferenceMode());
                this.toolsToggle.addEventListener('click', () => { this.renderToolsList(); this.togglePopup('tools'); });
                this.historyToggle.addEventListener('click', () => { this.renderChatHistory(); this.togglePopup('history'); });
                this.readmeToggle.addEventListener('click', () => { this.showReadmeMain(); this.togglePopup('readme'); });
                this.openInNewTabBtn.addEventListener('click', () => window.open(window.location.href, '_blank'));
                
                this.clearChatBtn.addEventListener('click', () => this.handleFabClick());
                this.messageInput.addEventListener('input', () => { this.autoResizeTextarea(); this.updateTokenEstimate(); });
                this.messageInput.addEventListener('keydown', (e) => this.handleKeyDown(e));
                this.sendMessage.addEventListener('click', () => this.sendUserMessage());
                this.togglePartialModeBtn.addEventListener('click', () => {
                    this.partialModeContainer.classList.toggle('hidden');
                    if(!this.partialModeContainer.classList.contains('hidden')) this.prefillInput.focus();
                });
                
                this.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
                this.manualImageInput.addEventListener('click', () => this.togglePopup('imageInput'));
                this.saveImageInputBtn.addEventListener('click', () => this.saveImageInput());
                this.cancelImageInputBtn.addEventListener('click', () => this.togglePopup('imageInput'));
                this.modelToggle.addEventListener('click', () => this.togglePopup('model'));

                this.themeToggle.addEventListener('change', (e) => this.setTheme(e.target.checked ? 'dark' : 'light'));
                this.streamToggle.addEventListener('change', (e) => {
                    this.streamMode = e.target.checked;
                    localStorage.setItem('streamMode', this.streamMode);
                    this.showStatus(`Streaming ${this.streamMode ? 'Enabled' : 'Disabled'}`, 'info');
                });
                
                this.pplxSearchToggle.addEventListener('change', (e) => {
                    this.pplxSearchEnabled = e.target.checked;
                    localStorage.setItem('pplxSearchEnabled', this.pplxSearchEnabled);
                });
                
                this.pplxRecencySelect.addEventListener('change', (e) => {
                    this.pplxRecency = e.target.value;
                    localStorage.setItem('pplxRecency', this.pplxRecency);
                    this.updateRecencyUI();
                });

                this.pplxStartDate.addEventListener('change', (e) => localStorage.setItem('pplxStartDate', e.target.value));
                this.pplxEndDate.addEventListener('change', (e) => localStorage.setItem('pplxEndDate', e.target.value));

                this.historySearch.addEventListener('input', () => this.renderChatHistory());

                document.querySelectorAll('.model-option').forEach(btn => {
                    btn.addEventListener('click', (e) => this.setModel(e.target.dataset.model, e.target.dataset.api));
                });
                document.querySelectorAll('.persona-option').forEach(btn => {
                    if(btn.dataset.persona) btn.addEventListener('click', () => this.setPersona(btn.dataset.persona));
                });

                document.getElementById('saveApiKeys').addEventListener('click', () => this.saveApiKeys());
                document.getElementById('showApiKeys').addEventListener('click', () => this.toggleApiKeysVisibility());
                document.getElementById('saveCustomPrompt').addEventListener('click', () => this.saveCustomPrompt());
                this.saveAsNewPersonaBtn.addEventListener('click', () => this.saveAsNewPersona());
                
                // NEW Import Button Listener
                this.importSingleChatBtn.addEventListener('click', () => this.importSingleChatInput.click());
                this.importSingleChatInput.addEventListener('change', (e) => this.importSingleChat(e));
                
                // Persona Export/Import Listeners
                this.exportPersonasBtn.addEventListener('click', () => this.exportPersonas());
                this.importPersonasBtn.addEventListener('click', () => this.importPersonasInput.click());
                this.importPersonasInput.addEventListener('change', (e) => this.importPersonas(e));

                this.addToolBtn.addEventListener('click', () => this.addTool());
                this.maxTokensSlider.addEventListener('input', (e) => this.updateMaxTokens(e.target.value));
                this.maxTokensInput.addEventListener('input', (e) => this.updateMaxTokens(e.target.value));
                this.runStorageDoctorBtn.addEventListener('click', () => this.runStorageDoctor());
                this.reqStorageAccessBtn.addEventListener('click', async () => {
                    const granted = await this.storageManager.ensureStorageAccess();
                    if(granted) {
                        this.showStatus('Storage Access Granted!', 'success');
                        this.initData(); // Reload
                    } else {
                        alert('Storage access denied by browser policy. Please open in a new tab.');
                    }
                });
                
                document.getElementById('closeReferencePopup').addEventListener('click', () => this.referencePopup.classList.add('hidden'));
                document.getElementById('openReference').addEventListener('click', () => this.openReference());
                document.getElementById('copyReference').addEventListener('click', () => this.copyReference());
                
                document.addEventListener('mouseup', (e) => this.handleTextSelection(e));
                this.selectionTooltip.addEventListener('click', () => this.openRevisionPopup());
                this.cancelRevisionBtn.addEventListener('click', () => this.closeRevisionPopup());
                this.saveRevisionBtn.addEventListener('click', () => this.saveRevision());
                document.addEventListener('click', (e) => this.handleOutsideClick(e));
                document.querySelectorAll('.popup-content').forEach(c => c.addEventListener('click', e => e.stopPropagation()));

                document.querySelectorAll('.feature-card').forEach(card => {
                    card.addEventListener('click', () => this.showReadmeDetail(card.dataset.feature));
                });
                this.readmeBackBtn.addEventListener('click', () => this.showReadmeMain());

                // --- Recency Info Icon Click ---
                document.getElementById('recencyInfoIcon').addEventListener('click', () => {
                    alert("Month, Week, and Day filters use the native Perplexity API parameter.\n\nYear and Custom Range filters are implemented by injecting specific instructions into the System Prompt to guide the model's search and generation, as the API does not natively support them.");
                });

                this.folderInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        const name = this.storageManager.handleLegacySelection(e.target.files);
                        document.getElementById('workspaceStatus').textContent = "Workspace: " + name + " (Legacy Mode)";
                        this.showStatus('Workspace Set (Legacy)', 'success');
                    }
                });
            }

            async runStorageDoctor() {
                const resEl = document.getElementById('storageDoctorResult');
                resEl.style.display = 'block';
                resEl.innerHTML = 'Scanning Database...';
                
                try {
                    const allData = await this.storageManager.dumpAllChats();
                    const count = allData.length;
                    let html = `<strong>Diagnosis Result:</strong><br>Found <b>${count}</b> saved chats in the hidden database.<br>`;
                    
                    if (count === 0) {
                        html += `<span style="color:var(--color-error)">Database is empty. External cleanup likely occurred.</span>`;
                    } else {
                        html += `<span style="color:var(--color-success)">Data exists!</span><br><br>`;
                        html += `<button class="btn btn--primary btn--sm" id="forceRestoreBtn">Force Restore All to Sidebar</button>`;
                    }
                    resEl.innerHTML = html;
                    
                    const btn = document.getElementById('forceRestoreBtn');
                    if(btn) {
                        btn.onclick = async () => {
                            // Re-populate metadata cache
                            this.savedChats = {};
                            allData.forEach(c => this.savedChats[c.id] = c);
                            // Render history
                            this.renderChatHistory();
                            // Load the most recent one to the active view
                            if (allData.length > 0) {
                                allData.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                                this.loadChat(allData[0].id);
                            }
                            this.showStatus('Restored ' + count + ' chats', 'success');
                            this.togglePopup('settings'); // Close settings
                        };
                    }
                } catch(e) {
                    resEl.innerHTML = `<span style="color:var(--color-error)">Error accessing DB: ${e.message}</span><br>If in iframe, try 'Connect Database' above.`;
                }
            }

            updateRecencyUI() {
                if(this.pplxRecency === 'custom') {
                    this.pplxCustomDateContainer.classList.remove('hidden');
                } else {
                    this.pplxCustomDateContainer.classList.add('hidden');
                }
            }
            
            handleWorkspaceClick() {
                if (this.storageManager.useLegacyMode || typeof window.showDirectoryPicker !== 'function') {
                    document.getElementById('folderInput').click();
                } else {
                    this.handleModernWorkspaceSelection();
                }
            }
            
            forceLegacyWorkspace() {
                this.storageManager.useLegacyMode = true;
                document.getElementById('folderInput').click();
            }
            
            async handleModernWorkspaceSelection() {
                const result = await this.storageManager.selectRootDirectory();
                if (result === 'FALLBACK') {
                    this.storageManager.useLegacyMode = true;
                    alert("Standard picker unavailable. Please click the 'Use Legacy Picker' link below.");
                } else if (result !== 'ABORT' && result) {
                    document.getElementById('workspaceStatus').textContent = "Workspace: " + result;
                    this.showStatus('Workspace Set', 'success');
                }
            }
            
            showReadmeDetail(featureKey) { /* ... same ... */
                const data = this.featureDetails[featureKey];
                if (!data) return;
                this.detailTitle.textContent = data.title;
                this.detailContent.innerHTML = data.content;
                this.readmeMainView.style.display = 'none';
                this.readmeDetailView.classList.add('active');
            }

            showReadmeMain() {
                this.readmeDetailView.classList.remove('active');
                this.readmeMainView.style.display = 'block';
            }

            renderSavedPersonas() { /* ... same ... */
                this.savedPersonasContainer.innerHTML = '';
                const ids = Object.keys(this.savedPersonas);
                if (ids.length === 0) {
                    this.savedPersonasContainer.innerHTML = '<div style="font-size:11px; color:var(--color-text-secondary); padding:4px;">No saved personas yet.</div>';
                    return;
                }
                ids.forEach(id => {
                    const p = this.savedPersonas[id];
                    const btn = document.createElement('button');
                    btn.className = 'persona-option';
                    if (this.currentPersona === id) btn.classList.add('active');
                    btn.innerHTML = `<span>üë§</span> ${p.name}`;
                    
                    const delBtn = document.createElement('span');
                    delBtn.innerHTML = '√ó';
                    delBtn.style.marginLeft = 'auto'; delBtn.style.padding = '2px 6px'; delBtn.style.cursor = 'pointer'; delBtn.style.color = 'var(--color-text-secondary)';
                    delBtn.onclick = (e) => { e.stopPropagation(); if (confirm('Delete persona?')) this.deleteSavedPersona(id); };
                    btn.appendChild(delBtn);
                    btn.onclick = (e) => { if (e.target === delBtn) return; this.setPersona(id); }
                    this.savedPersonasContainer.appendChild(btn);
                });
            }

            /* ... existing methods ... */
            saveAsNewPersona() {
                const name = document.getElementById('customPersonaName').value.trim();
                const prompt = document.getElementById('customPrompt').value;
                if(!name) return this.showStatus('Name required', 'warning');
                const id = 'custom_' + Date.now();
                const newPersona = { name, prompt };
                this.savedPersonas[id] = newPersona; this.personas[id] = newPersona;
                localStorage.setItem('saved_personas', JSON.stringify(this.savedPersonas));
                this.renderSavedPersonas(); this.setPersona(id); this.showStatus('Persona Saved', 'success');
            }
            deleteSavedPersona(id) {
                delete this.savedPersonas[id]; delete this.personas[id];
                localStorage.setItem('saved_personas', JSON.stringify(this.savedPersonas));
                if (this.currentPersona === id) this.setPersona('allrounder');
                else this.renderSavedPersonas();
            }
            createNewSession() {
                const id = Date.now().toString();
                this.sessions[id] = { id: id, name: `Topic ${this.sessionCounter++}`, messages: [], references: {} };
                this.switchSession(id);
                // Save immediately to ensure tab persists on reload even if empty
                this.autoSaveChat();
                this.persistSessionState();
            }
            switchSession(id) {
                if (!this.sessions[id]) return;
                this.activeSessionId = id; this.messages = this.sessions[id].messages; this.references = this.sessions[id].references; this.currentChatId = id;
                this.renderTabs(); this.renderMessages();
                this.persistSessionState();
            }
            
            handleFabClick() {
                if(this.clearConfirmTimer) {
                    clearTimeout(this.clearConfirmTimer);
                    this.clearConfirmTimer = null;
                    this.resetFab();
                    this.performClear();
                } else {
                    this.clearChatBtn.textContent = 'x';
                    this.clearChatBtn.classList.add('confirm-state');
                    this.clearConfirmTimer = setTimeout(() => this.resetFab(), 3000);
                }
            }
            
            resetFab() {
                this.clearChatBtn.textContent = 'üóëÔ∏è';
                this.clearChatBtn.classList.remove('confirm-state');
                this.clearConfirmTimer = null;
            }

            performClear() {
                if (!this.activeSessionId || !this.sessions[this.activeSessionId]) return;
                this.sessions[this.activeSessionId].messages = [];
                this.sessions[this.activeSessionId].references = {};
                this.messages = [];
                this.references = {};
                this.renderMessages();
                this.autoSaveChat();
                this.showStatus('Chat Cleared', 'info');
            }
            
            closeSession(id, e) {
                if(e) e.stopPropagation();
                if (Object.keys(this.sessions).length <= 1) {
                    this.sessions[id].messages = []; this.sessions[id].references = {}; this.sessions[id].name = `Topic ${this.sessionCounter++}`;
                    this.switchSession(id); return;
                }
                delete this.sessions[id];
                if (this.activeSessionId === id) { const remainingIds = Object.keys(this.sessions); this.switchSession(remainingIds[remainingIds.length - 1]); } 
                else { this.renderTabs(); this.persistSessionState(); }
            }
            renderTabs() {
                this.tabsBar.innerHTML = '';
                Object.values(this.sessions).forEach(session => {
                    const tab = document.createElement('div');
                    tab.className = `tab ${session.id === this.activeSessionId ? 'active' : ''}`;
                    tab.onclick = (e) => {
                        if(e.target.classList.contains('tab-close') || e.target.classList.contains('tab-edit') || e.target.tagName === 'INPUT') return;
                        this.switchSession(session.id);
                    };
                    const nameSpan = document.createElement('span'); nameSpan.className = 'tab-name'; nameSpan.textContent = session.name;
                    const editBtn = document.createElement('span'); editBtn.className = 'tab-edit'; editBtn.innerHTML = '‚úé';
                    editBtn.onclick = (e) => { e.stopPropagation(); this.startTabRenaming(session.id, nameSpan); };
                    const closeBtn = document.createElement('span'); closeBtn.className = 'tab-close'; closeBtn.innerHTML = '√ó';
                    closeBtn.onclick = (e) => this.closeSession(session.id, e);
                    tab.append(nameSpan, editBtn, closeBtn);
                    this.tabsBar.appendChild(tab);
                });
                const addBtn = document.createElement('div');
                addBtn.className = 'tab tab-add-btn';
                addBtn.innerHTML = '+';
                addBtn.onclick = () => this.createNewSession();
                this.tabsBar.appendChild(addBtn);
            }
            startTabRenaming(id, el) {
                const input = document.createElement('input'); input.className = 'tab-name-input'; input.value = this.sessions[id].name;
                input.onblur = () => this.saveTabName(id, input.value);
                input.onkeydown = (e) => { if(e.key === 'Enter') input.blur(); };
                el.innerHTML = ''; el.appendChild(input); input.focus();
            }
            saveTabName(id, newName) {
                const name = newName.trim();
                if(name) {
                    this.sessions[id].name = name;
                    this.autoSaveChat(); // Update DB
                }
                this.renderTabs(); this.renderChatHistory();
            }

            renderMessages() {
                this.messagesContainer.innerHTML = '';
                this.messages.forEach((msg, idx) => {
                    this.messagesContainer.appendChild(this.createMessageElement(msg, idx));
                });
                this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
            }

            createMessageElement(message, index) { /* ... same ... */
                const messageEl = document.createElement('div');
                messageEl.className = `message ${message.role}`;
                
                const headerEl = document.createElement('div');
                headerEl.className = 'message-header';
                const roleEl = document.createElement('span');
                roleEl.className = 'message-role';
                roleEl.textContent = message.role === 'user' ? 'You' : 'Assistant';
                headerEl.appendChild(roleEl);

                const actionsEl = document.createElement('div');
                actionsEl.className = 'msg-actions';
                if (message.role === 'user') {
                    const editBtn = document.createElement('button'); editBtn.className = 'msg-btn'; editBtn.innerHTML = '‚úé'; editBtn.title = 'Edit Prompt';
                    editBtn.onclick = () => this.enableMessageEditing(index); actionsEl.appendChild(editBtn);
                }
                const copyBtn = document.createElement('button'); copyBtn.className = 'msg-btn'; copyBtn.innerHTML = 'üìã'; copyBtn.title = 'Copy';
                copyBtn.onclick = () => this.copyMessage(message.content); actionsEl.appendChild(copyBtn);
                headerEl.appendChild(actionsEl);

                const contentEl = document.createElement('div');
                contentEl.className = 'message-content';
                if (message.image && message.role === 'user') {
                    contentEl.innerHTML += `<img src="${message.image}" class="message-image" alt="User Image">`;
                }
                if (message.content) {
                    if (message.role === 'assistant') {
                        Object.assign(this.references, this.extractReferencesFromResponse(message));
                    }
                    contentEl.innerHTML += this.renderEnhancedMarkdown(message.content);
                    if (message.isStreaming) contentEl.classList.add('streaming-cursor');
                    
                    if (message.role === 'assistant') {
                        this.attachReferenceHandlers(contentEl);
                        this.processHighcharts(contentEl);
                        this.processTables(contentEl);
                        if (window.mermaid) { try { mermaid.init(undefined, contentEl.querySelectorAll('.mermaid')); } catch(e) {} }
                        if (window.renderMathInElement) { try { renderMathInElement(contentEl, { delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\(', right: '\\)', display: false}, {left: '\\[', right: '\\]', display: true}], throwOnError: false }); } catch(e) {} }

                        const exportBtn = document.createElement('button'); exportBtn.className = 'message-export-btn'; exportBtn.innerHTML = 'üìÑ'; exportBtn.title = 'Open in New Window';
                        exportBtn.onclick = () => this.exportMessageToWindow(message.content);
                        messageEl.appendChild(exportBtn);

                        const forkBtn = document.createElement('button'); forkBtn.className = 'message-fork-btn'; forkBtn.innerHTML = 'üåø'; forkBtn.title = 'Fork Conversation';
                        forkBtn.onclick = () => this.forkConversation(index);
                        messageEl.appendChild(forkBtn);
                    }
                    if (window.hljs) contentEl.querySelectorAll('pre code').forEach(b => hljs.highlightBlock(b));
                }

                messageEl.append(headerEl, contentEl);
                
                // Show token usage if available
                if (message.role === 'assistant' && message.tokenUsage) {
                    messageEl.appendChild(this.createTokenInfoElement(message.tokenUsage));
                }
                return messageEl;
            }

            forkConversation(index) {
                const currentMsgs = this.messages.slice(0, index + 1);
                const currentRefs = { ...this.references };
                const id = Date.now().toString();
                const newName = `Fork of ${this.sessions[this.activeSessionId].name}`;
                this.sessions[id] = { id: id, name: newName, messages: JSON.parse(JSON.stringify(currentMsgs)), references: currentRefs };
                this.switchSession(id);
                this.showStatus('Conversation Forked', 'success');
            }

            exportMessageToWindow(content) {
                let processedContent = content;
                if (!this.showReferences) processedContent = processedContent.replace(/\[\d+\]/g, '');
                const htmlContent = this.converter.makeHtml(processedContent);
                const win = window.open('', '_blank');
                if(!win) return;
                win.document.title = "Conversation Export";
                
                const fullHTML = `
                    <html>
                    <head>
                        <title>Conversation Export</title>
                        <style>
                            body { font-family: sans-serif; padding: 40px; line-height: 1.6; max-width: 800px; margin: 0 auto; color: #333; }
                            table { border-collapse: collapse; width: 100%; margin: 20px 0; border: 1px solid #ddd; }
                            th, td { padding: 12px; border: 1px solid #ddd; text-align: left; }
                            th { background-color: #f8f9fa; }
                            pre { background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto; }
                            blockquote { border-left: 4px solid #ddd; padding-left: 15px; color: #666; margin: 0; }
                            .btn { padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; text-decoration: none; display: inline-block; margin-bottom: 20px; margin-right: 10px; }
                            .btn-secondary { background: #6c757d; }
                            @media print { .btn { display: none; } }
                        </style>
                    </head>
                    <body>
                        <div id="controls">
                            <button class="btn" onclick="window.print()">Print / Save as PDF</button>
                            <button class="btn btn-secondary" onclick="downloadAsWord()">Download as Word</button>
                        </div>
                        <div id="content">${htmlContent}</div>
                        <script>
                            function downloadAsWord() {
                                var header = "<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'><head><meta charset='utf-8'><title>Export Document</title></head><body>";
                                var footer = "</body></html>";
                                var sourceHTML = header + document.getElementById('content').innerHTML + footer;
                                var source = 'data:application/vnd.ms-word;charset=utf-8,' + encodeURIComponent(sourceHTML);
                                var fileDownload = document.createElement("a");
                                document.body.appendChild(fileDownload);
                                fileDownload.href = source;
                                fileDownload.download = 'conversation.doc';
                                fileDownload.click();
                                document.body.removeChild(fileDownload);
                            }
                        <\/script>
                    </body>
                    </html>
                `;
                win.document.write(fullHTML);
                win.document.close();
            }

            loadTheme() {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) { this.setTheme(savedTheme); } 
                else { 
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches; 
                    this.setTheme(prefersDark ? 'dark' : 'light'); 
                }
            }

            setTheme(theme) {
                document.documentElement.setAttribute('data-color-scheme', theme);
                localStorage.setItem('theme', theme);
                if (this.themeToggle) this.themeToggle.checked = (theme === 'dark');
            }
            
            updateUI() {
                if(this.themeToggle) this.themeToggle.checked = (localStorage.getItem('theme') === 'dark');
                if(this.streamToggle) this.streamToggle.checked = this.streamMode;
                if(this.pplxSearchToggle) this.pplxSearchToggle.checked = this.pplxSearchEnabled;
                if(this.pplxRecencySelect) this.pplxRecencySelect.value = this.pplxRecency;
                if(this.pplxStartDate) this.pplxStartDate.value = localStorage.getItem('pplxStartDate') || '';
                if(this.pplxEndDate) this.pplxEndDate.value = localStorage.getItem('pplxEndDate') || '';
                this.updateRecencyUI();
                this.updatePersonaOptions(); this.updateModelOptions();
                if(this.oneShotToggle) this.oneShotToggle.classList.toggle('active', this.oneShotMode);
                if(this.refToggle) this.refToggle.classList.toggle('active', this.showReferences);
                if(this.feedbackToggle) this.feedbackToggle.classList.toggle('active', this.feedbackMode);
            }

            renderEnhancedMarkdown(text) { /* ... same ... */
                if (!text) return '';
                let processedText = String(text);
                processedText = processedText.replace(/<pre><code class="mermaid">([\s\S]*?)<\/code><\/pre>/g, '<div class="mermaid">$1</div>');
                processedText = processedText.replace(/```mermaid([\s\S]*?)```/g, '<div class="mermaid">$1</div>');
                const thinkBlocks = new Map();
                processedText = processedText.replace(/<think>([\s\S]*?)<\/think>/gi, (match, content) => {
                    const id = `THINKBLOCKTOKEN${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
                    thinkBlocks.set(id, content.trim());
                    return id;
                });
                processedText = processedText.replace(/(^|\n)(\d+)\.\s/gm, '$1$2. ');
                let html;
                try { html = this.converter.makeHtml(processedText); } catch (e) { html = processedText.replace(/\n/g, '<br>'); }
                thinkBlocks.forEach((content, id) => {
                    let innerHtml;
                    try { innerHtml = this.converter.makeHtml(content); } catch (e) { innerHtml = content.replace(/\n/g, '<br>'); }
                    const detailsHtml = `<details class="thinking-details"><summary>Thinking Process</summary><div class="thinking-content">${innerHtml}</div></details>`;
                    html = html.replace(new RegExp(id, 'g'), () => detailsHtml);
                });
                html = html.replace(/<pre><code class="([^"]*)"([^>]*)>([\s\S]*?)<\/code><\/pre>/g, (match, langClass, attrs, code) => {
                    if (langClass.includes('mermaid')) return `<div class="mermaid">${code}</div>`;
                    const language = langClass ? langClass.replace('language-', '') : 'text';
                    const codeId = 'code-' + Math.random().toString(36).substr(2, 9);
                    return `<div class="code-block"><div class="code-header"><span class="code-language">${language}</span><button class="code-copy-btn" onclick="copyCodeBlock('${codeId}', this)">Copy</button></div><pre><code id="${codeId}" class="${langClass}"${attrs}>${code}</code></pre></div>`;
                });
                if (this.showReferences) html = html.replace(/\[(\d+)\]/g, '<span class="reference-link" data-ref="$1">[$1]</span>');
                else html = html.replace(/\[\d+\]/g, '');
                return html;
            }

            autoResizeTextarea() { 
                this.messageInput.style.height = 'auto'; 
                const newHeight = Math.min(this.messageInput.scrollHeight, 150);
                this.messageInput.style.height = (newHeight + 2) + 'px';
                if(this.messageInput.value.length > 0) { this.messageInput.scrollTop = this.messageInput.scrollHeight; }
            }
            handleKeyDown(e) { if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); this.sendUserMessage(); } }
            
            updateHeaderStatus() {
                let modelName = this.currentModel;
                this.modelStatus.textContent = `Model: ${modelName}`;
                this.personaStatus.textContent = `Persona: ${this.personas[this.currentPersona]?.name || 'Unknown'}`;
            }
            updateTokenConfigUI() {
                this.maxTokensSlider.value = this.maxTokens;
                this.maxTokensInput.value = this.maxTokens;
                this.maxTokensValue.textContent = this.maxTokens;
            }
            updatePartialModeButton() {
                if(this.currentAPI === 'moonshot') this.togglePartialModeBtn.classList.remove('hidden');
                else { this.togglePartialModeBtn.classList.add('hidden'); this.partialModeContainer.classList.add('hidden'); }
            }
            togglePopup(type) { /* ... same ... */
                const popups = ['settings', 'persona', 'model', 'apiKey', 'imageInput', 'history', 'revision', 'tools', 'readme'];
                popups.forEach(p => { if (p !== type) document.getElementById(`${p}Popup`).classList.add('hidden'); });
                const popup = document.getElementById(`${type}Popup`);
                if(popup) {
                    popup.classList.toggle('hidden');
                    if (type === 'persona') this.setPersona(this.currentPersona);
                    if (type === 'apiKey') {
                        document.getElementById('perplexityApiKey').value = this.apiKeys.perplexity;
                        document.getElementById('moonshotApiKey').value = this.apiKeys.moonshot;
                    }
                }
            }
            toggleOneShotMode() {
                this.oneShotMode = !this.oneShotMode;
                localStorage.setItem('oneShotMode', this.oneShotMode.toString());
                if(this.oneShotToggle) this.oneShotToggle.classList.toggle('active', this.oneShotMode);
                this.showStatus(this.oneShotMode ? 'One-shot mode enabled' : 'Disabled', 'info');
            }
            toggleFeedbackMode() {
                this.feedbackMode = !this.feedbackMode;
                localStorage.setItem('feedbackMode', this.feedbackMode);
                if(this.feedbackToggle) this.feedbackToggle.classList.toggle('active', this.feedbackMode);
                this.showStatus(this.feedbackMode ? 'Feedback Loop Enabled' : 'Disabled', 'info');
            }
            toggleReferenceMode() {
                this.showReferences = !this.showReferences;
                localStorage.setItem('showReferences', this.showReferences);
                if(this.refToggle) this.refToggle.classList.toggle('active', this.showReferences);
                this.renderMessages();
            }
            renderToolsList() { /* ... same ... */
                this.renderGenericList(this.localTools, 'toolsList', (item) => {
                    return `<div class="history-item" style="display:flex; justify-content:space-between; padding:8px; border:1px solid var(--color-border); border-radius:4px;"><div style="flex:1;"><b>${item.name}</b><br><small style="color:var(--color-text-secondary);">${item.path}</small></div><div class="history-actions" style="display:flex; gap:4px;"><button class="btn btn--primary btn--sm" onclick="window.chatApp.openTool('${item.path}')">Open</button><button class="btn btn--secondary btn--sm" onclick="window.chatApp.deleteTool(${item.id})">üóëÔ∏è</button></div></div>`;
                });
            }
            renderChatHistory() {
                const query = this.historySearch.value.toLowerCase();
                const ids = Object.keys(this.savedChats).filter(id => {
                    const chat = this.savedChats[id];
                    return !query || chat.name.toLowerCase().includes(query);
                }).sort((a,b) => {
                    const ca = this.savedChats[a];
                    const cb = this.savedChats[b];
                    // Sort by pinned (true first), then by timestamp (newest first)
                    if (!!ca.isPinned !== !!cb.isPinned) return cb.isPinned ? 1 : -1;
                    return (cb.timestamp||0) - (ca.timestamp||0);
                });

                const container = document.getElementById('historyList');
                container.innerHTML = ids.length ? '' : '<p style="text-align:center;color:var(--color-text-secondary);font-size:13px;margin-top:20px;">No saved chats found.</p>';
                
                ids.forEach(id => {
                    const chat = this.savedChats[id];
                    const div = document.createElement('div');
                    div.className = 'history-item';
                    if (chat.isPinned) div.style.backgroundColor = 'var(--color-bg-1)'; // Highlight pinned
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'history-name';
                    // Visual pin indicator in title
                    nameSpan.innerHTML = (chat.isPinned ? '<span style="opacity:0.8; margin-right:4px;">üìå</span>' : '') + (chat.name || 'Untitled Chat');
                    nameSpan.onclick = () => { this.loadChat(id); };
                    
                    // Inline Actions
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'history-actions';
                    
                    // Pin Button
                    const pinBtn = document.createElement('button');
                    pinBtn.className = `history-action-btn ${chat.isPinned ? 'active' : ''}`;
                    pinBtn.innerHTML = 'üìå';
                    pinBtn.title = chat.isPinned ? 'Unpin' : 'Pin';
                    if(chat.isPinned) pinBtn.style.color = 'var(--color-primary)';
                    pinBtn.onclick = (e) => { e.stopPropagation(); this.togglePin(id); };

                    // Export Button (Fixed Icon)
                    const exportBtn = document.createElement('button');
                    exportBtn.className = 'history-action-btn';
                    exportBtn.innerHTML = 'üíæ'; 
                    exportBtn.title = 'Export JSON';
                    exportBtn.onclick = (e) => { e.stopPropagation(); this.exportSingleChat(id); };
                    
                    // Delete Button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'history-action-btn delete';
                    deleteBtn.innerHTML = 'üóëÔ∏è';
                    deleteBtn.title = 'Delete';
                    deleteBtn.onclick = (e) => { e.stopPropagation(); if(confirm('Delete this chat?')) this.deleteChat(id); };
                    
                    actionsDiv.append(pinBtn, exportBtn, deleteBtn);
                    div.append(nameSpan, actionsDiv);
                    container.appendChild(div);
                });
            }
            
            async togglePin(id) {
                const chat = await this.storageManager.getChat(id);
                if (chat) {
                    chat.isPinned = !chat.isPinned;
                    await this.storageManager.saveChat(chat);
                    // Update local metadata cache
                    if (this.savedChats[id]) {
                        this.savedChats[id].isPinned = chat.isPinned;
                    }
                    this.renderChatHistory();
                }
            }

            renderGenericList(items, containerId, mapFn) {
                const container = document.getElementById(containerId);
                container.innerHTML = items.length ? '' : '<p style="text-align:center;color:var(--color-text-secondary);">Empty</p>';
                items.forEach(item => {
                    const el = document.createElement('div'); el.innerHTML = mapFn(item); container.appendChild(el.firstChild);
                });
            }
            showStatus(msg, type='info') {
                this.statusIndicator.textContent = msg; this.statusIndicator.className = `status status--${type} show`;
                setTimeout(() => { this.statusIndicator.classList.remove('show'); this.statusIndicator.classList.add('hidden'); }, 3000);
            }
            setModel(m, a, openPopup = true) { 
                if(!m || !a) return; 
                this.currentModel = m; this.currentAPI = a; localStorage.setItem('currentModel', m); localStorage.setItem('currentAPI', a); this.updateHeaderStatus(); this.updatePartialModeButton();
                if(openPopup) this.togglePopup('model'); 
                this.updateModelOptions(); 
            }
            updateModelOptions() { document.querySelectorAll('.model-option').forEach(b => b.classList.toggle('active', b.dataset.model === this.currentModel)); }
            setPersona(p) { 
                this.currentPersona = p; localStorage.setItem('currentPersona', p); this.updateHeaderStatus(); this.updatePersonaOptions();
                const isStd = ['allrounder','excel','grammar','auditor'].includes(p);
                const cs = document.getElementById('customPromptSection');
                if(!isStd) { cs.classList.remove('hidden'); const d = this.personas[p]; if(d){ document.getElementById('customPersonaName').value = d.name; document.getElementById('customPrompt').value = d.prompt; }}
                else cs.classList.add('hidden');
            }
            updatePersonaOptions() { document.querySelectorAll('.persona-option').forEach(b => b.classList.toggle('active', b.dataset.persona === this.currentPersona)); }
            
            async sendUserMessage() {
                // If loading, clicking button acts as STOP
                if (this.isLoading) {
                    if (this.abortController) {
                        this.abortController.abort();
                        this.abortController = null;
                        this.showStatus('Generation Stopped', 'info');
                    }
                    return;
                }

                const msg = this.messageInput.value.trim();
                const pre = this.prefillInput.value.trim();
                if (!msg && !this.uploadedImage && !this.uploadedTextContext) return;
                if (this.oneShotMode && this.messages.length > 0) { this.messages = []; this.references = {}; }
                
                let fullContent = msg;
                if (this.uploadedTextContext) {
                    fullContent = `[Attached File: ${this.uploadedFileName}]\n\n${this.uploadedTextContext}\n\n[End of File]\n\n${msg}`;
                }

                const newUserMsg = { role: 'user', content: fullContent, image: this.uploadedImage, timestamp: new Date() };
                this.messages.push(newUserMsg);
                
                // IMMEDIATE UI UPDATE: Clear inputs to prevent perceived lag
                this.messageInput.value = ''; 
                this.prefillInput.value = ''; 
                this.partialModeContainer.classList.add('hidden');
                this.resetTextareaSize(); 
                this.removeImagePreview(); 
                
                // Cache these before clearing for API call logic if needed
                const currentImage = this.uploadedImage;
                
                this.uploadedImage = null; 
                this.uploadedTextContext = null; 
                this.uploadedFileName = null;
                this.updateTokenEstimate(); 

                // Defer heavy rendering and saving to next tick to free up UI thread
                requestAnimationFrame(() => {
                    this.renderMessages();
                    // Defer saving even more to prevent blocking
                    setTimeout(() => this.autoSaveChat(), 50);
                });
                
                if (!this.apiKeys[this.currentAPI]) { this.showStatus('No API Key', 'error'); return; }
                this.setLoading(true);
                this.abortController = new AbortController();

                try {
                    if (this.streamMode) await this.streamResponse(fullContent, pre);
                    else {
                        const res = await this.callAPI(fullContent, pre);
                        const content = pre ? pre + res.content : res.content;
                        this.messages.push({ role: 'assistant', content, timestamp: new Date(), tokenUsage: res.tokenUsage, searchResults: res.searchResults, citations: res.citations });
                        this.renderMessages(); this.autoSaveChat();
                    }
                } catch (e) {
                    if (e.name === 'AbortError') {
                        // Stopped by user, do nothing special
                    } else {
                        this.showStatus('Error: ' + e.message, 'error'); 
                        this.messages.push({ role: 'assistant', content: 'Error: ' + e.message }); 
                        this.renderMessages(); 
                    }
                } finally { 
                    this.setLoading(false); 
                    this.abortController = null;
                }
            }
            
            startNewTopic() { this.createNewSession(); this.showStatus('New Topic Started', 'success'); }
            resetTextareaSize() { this.messageInput.style.height = 'auto'; this.messageInput.rows = 1; }
            removeImagePreview() { if (this.imagePreview) { this.imagePreview.classList.add('hidden'); this.imagePreview.innerHTML = ''; } this.uploadedImage = null; this.uploadedTextContext = null; this.fileInput.value = ''; this.updateTokenEstimate(); }
            
            setLoading(l) { 
                this.isLoading = l; 
                if(l) {
                    this.sendMessage.textContent = '‚ñ†'; // Stop icon
                    this.sendMessage.classList.add('stop');
                    if(!this.streamMode) { 
                        const div = document.createElement('div'); div.className='message assistant loading'; div.textContent='Loading...'; this.messagesContainer.appendChild(div); 
                    }
                } else { 
                    this.sendMessage.textContent = '‚Üí'; 
                    this.sendMessage.classList.remove('stop');
                    const loader = this.messagesContainer.querySelector('.loading'); if(loader) loader.remove(); 
                } 
            }

            async callAPI(msg, pre) {
                const msgs = this.buildMessagesForAPI(pre);
                const body = { model: this.currentModel, messages: msgs, max_tokens: this.maxTokens, temperature: 0.2, stream: false };
                
                // Perplexity Search Logic
                if (this.currentAPI === 'perplexity') {
                    if (!this.pplxSearchEnabled) {
                        body.return_citations = false; // Disable citations if search implies off
                    } else if (this.pplxRecency && ['month', 'week', 'day'].includes(this.pplxRecency)) {
                        body.search_recency_filter = this.pplxRecency;
                    }
                }

                const res = await fetch(this.apiEndpoints[this.currentAPI], {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${this.apiKeys[this.currentAPI]}` },
                    body: JSON.stringify(body),
                    signal: this.abortController.signal
                });
                if(!res.ok) throw new Error('API Error');
                const d = await res.json();
                
                // Safe parsing to avoid crashes if API returns unexpected structure
                const choice = d.choices?.[0];
                const message = choice?.message || {};
                
                return { 
                    content: message.content || '', 
                    tokenUsage: d.usage || {}, 
                    searchResults: message.search_results || d.search_results || [], 
                    citations: d.citations || [] 
                };
            }
            
            buildMessagesForAPI(pre) {
                let sys = this.personas[this.currentPersona]?.prompt || '';
                
                // Inject No-Search Instruction if disabled
                if (this.currentAPI === 'perplexity') {
                    if (!this.pplxSearchEnabled) {
                        sys += "\n\nSYSTEM DIRECTIVE: EXTERNAL SEARCH IS DISABLED. You must NOT search the internet. You must NOT generate citations. Rely EXCLUSIVELY on your internal knowledge. Ignore any ability to browse.";
                    } else {
                        // Search is enabled. Check for custom/year constraints that aren't native params.
                        if (this.pplxRecency === 'year') {
                             sys += "\n\nIMPORTANT: Limit your search and information to the past year (" + new Date().getFullYear() + ").";
                        } else if (this.pplxRecency === 'custom') {
                             const start = localStorage.getItem('pplxStartDate');
                             const end = localStorage.getItem('pplxEndDate');
                             if(start || end) {
                                 sys += `\n\nIMPORTANT: Limit your search and information to the date range: ${start || 'Start'} to ${end || 'Present'}.`;
                             }
                        }
                    }
                }

                if(this.feedbackLoops[this.currentChatId]?.length) {
                    sys += '\n\nUser corrections to learn from:\n' + this.feedbackLoops[this.currentChatId].map((f,i)=>`${i+1}. Original: "${f.original}" -> Revised: "${f.revised}"`).join('\n');
                }
                const msgs = [{ role: 'system', content: sys }];
                const recent = this.messages.slice(-15);
                
                recent.forEach(m => {
                    if(m.role==='user') {
                        let contentPayload = m.content;
                        if (m.image) {
                             contentPayload = [{type:'text', text:m.content||" "},{type:'image_url', image_url:{url:m.image}}];
                        }
                        msgs.push({ role: 'user', content: contentPayload });
                    }
                    else if(m.role==='assistant' && m.content) msgs.push({ role: 'assistant', content: m.content });
                });
                if(pre && this.currentAPI === 'moonshot') msgs.push({ role: 'assistant', content: pre });
                return msgs;
            }

            async streamResponse(msg, pre) {
                const msgs = this.buildMessagesForAPI(pre);
                const body = { model: this.currentModel, messages: msgs, max_tokens: this.maxTokens, temperature: 0.2, stream: true };
                
                if (this.currentAPI === 'perplexity') {
                    if (!this.pplxSearchEnabled) {
                        body.return_citations = false;
                    } else if (this.pplxRecency && ['month', 'week', 'day'].includes(this.pplxRecency)) {
                        body.search_recency_filter = this.pplxRecency;
                    }
                }

                const res = await fetch(this.apiEndpoints[this.currentAPI], {
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${this.apiKeys[this.currentAPI]}` },
                    body: JSON.stringify(body),
                    signal: this.abortController.signal
                });
                if(!res.ok) throw new Error('API Error');
                
                const assistantMessage = { role: 'assistant', content: pre || '', timestamp: new Date(), isStreaming: true, searchResults: [] };
                this.messages.push(assistantMessage);
                this.renderMessages();
                
                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let done = false;
                let buffer = ''; 
                
                const msgElement = this.messagesContainer.lastElementChild;
                const contentDiv = msgElement.querySelector('.message-content');

                try {
                    while(!done) {
                        const { value, done: d } = await reader.read();
                        done = d;
                        buffer += decoder.decode(value, {stream: true});
                        
                        const lines = buffer.split('\n');
                        buffer = lines.pop(); 

                        lines.forEach(line => {
                            if(line.startsWith('data: ')) {
                                const dataStr = line.slice(6);
                                if(dataStr.trim() === '[DONE]') return;
                                try {
                                    const data = JSON.parse(dataStr);
                                    if(data.citations) assistantMessage.citations = data.citations;
                                    if(data.search_results) assistantMessage.searchResults = data.search_results;
                                    else if(data.choices?.[0]?.message?.search_results) assistantMessage.searchResults = data.choices[0].message.search_results;
                                    
                                    if (data.usage) assistantMessage.tokenUsage = data.usage;

                                    const delta = data.choices?.[0]?.delta?.content || "";
                                    if(delta) {
                                        assistantMessage.content += delta;
                                        contentDiv.innerHTML = this.renderEnhancedMarkdown(assistantMessage.content) + '<span class="streaming-cursor">‚ñã</span>';
                                        if (window.renderMathInElement) try{renderMathInElement(contentDiv, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\(', right: '\\)', display: false}, {left: '\\[', right: '\\]', display: true}], throwOnError:false});}catch(e){}
                                        if (window.mermaid) try{mermaid.init(undefined, contentDiv.querySelectorAll('.mermaid'));}catch(e){}
                                        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
                                    }
                                } catch(e){}
                            }
                        });
                    }
                } catch(e){ 
                    if (e.name !== 'AbortError') assistantMessage.content += '\n[Error]'; 
                } finally { 
                    assistantMessage.isStreaming = false;
                    if(assistantMessage.citations) Object.assign(this.references, this.extractReferencesFromResponse(assistantMessage));
                    this.renderMessages(); 
                    this.autoSaveChat(); 
                }
            }
            
            saveImageInput() { /* ... same ... */
                const val = document.getElementById('imageInputString').value;
                if(val) { 
                    this.uploadedImage = val; 
                    this.showStatus('Image Set', 'success'); 
                    this.togglePopup('imageInput');
                    const preview = document.getElementById('imagePreview');
                    preview.classList.remove('hidden');
                    preview.innerHTML = `<img src="${this.uploadedImage}" class="preview-image"><span class="remove-image-btn" onclick="window.chatApp.removeImagePreview()">√ó</span>`;
                    this.updateTokenEstimate();
                    if(this.currentAPI === 'perplexity' && this.currentModel !== 'sonar-pro') {
                        this.setModel('sonar-pro', 'perplexity', false);
                        this.showStatus('Switched to Sonar Pro (Image Support)', 'info');
                    }
                }
            }
            
            async handleFileUpload(e) { /* ... same ... */
                const f = e.target.files[0];
                if (!f) return;
                
                this.uploadedFileName = f.name;
                const preview = document.getElementById('imagePreview');
                preview.classList.remove('hidden');
                
                if (f.type.startsWith('image/')) {
                    const r = new FileReader();
                    r.onload = (ev) => { 
                        this.uploadedImage = ev.target.result; 
                        preview.innerHTML = `<img src="${this.uploadedImage}" class="preview-image"><span class="remove-image-btn" onclick="window.chatApp.removeImagePreview()">√ó</span>`;
                        this.showStatus('Image Ready', 'success');
                        this.updateTokenEstimate();
                        if(this.currentAPI === 'perplexity' && this.currentModel !== 'sonar-pro') {
                            this.setModel('sonar-pro', 'perplexity', false);
                            this.showStatus('Switched to Sonar Pro (Image Support)', 'info');
                        }
                    };
                    r.readAsDataURL(f);
                } else if (f.type === 'application/pdf') {
                    try {
                        const arrayBuffer = await f.arrayBuffer();
                        const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                        let fullText = "";
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += `--- Page ${i} ---\n${pageText}\n\n`;
                        }
                        this.uploadedTextContext = fullText.trim();
                        preview.innerHTML = `<span class="file-preview-icon">üìÑ</span> <span>${f.name} (PDF, ${pdf.numPages} pg)</span><span class="remove-image-btn" onclick="window.chatApp.removeImagePreview()">√ó</span>`;
                        this.showStatus('PDF Parsed', 'success');
                        this.updateTokenEstimate();
                    } catch (err) {
                        this.showStatus('PDF Error: ' + err.message, 'error');
                        console.error(err);
                    }
                } else {
                    const r = new FileReader();
                    r.onload = (ev) => {
                        this.uploadedTextContext = ev.target.result;
                        let icon = 'üìÑ';
                        if (f.name.endsWith('.csv')) icon = 'üìä';
                        if (f.name.endsWith('.json')) icon = '{ }';
                        if (f.name.endsWith('.js') || f.name.endsWith('.py')) icon = 'üíª';
                        preview.innerHTML = `<span class="file-preview-icon">${icon}</span> <span>${f.name} (${Math.round(f.size/1024)}KB)</span><span class="remove-image-btn" onclick="window.chatApp.removeImagePreview()">√ó</span>`;
                        this.showStatus('File Read', 'success');
                        this.updateTokenEstimate();
                    };
                    r.readAsText(f);
                }
            }

            updateTokenEstimate() { /* ... same ... */
                let text = this.messageInput.value || "";
                if (this.uploadedTextContext) text += this.uploadedTextContext;
                const len = text.length;
                const estTokens = Math.ceil(len / 3.5); 
                this.tokenEst.textContent = `~${estTokens} toks`;
                this.tokenEst.classList.remove('hidden');
                if (estTokens > 100000) this.tokenEst.style.color = 'var(--color-error)';
                else this.tokenEst.style.color = 'var(--color-text-secondary)';
            }
            
            extractReferencesFromResponse(msg) { /* ... same ... */
                if (!msg.citations || !Array.isArray(msg.citations)) return {};
                const refs = {};
                const normalize = (u) => u ? u.replace(/^https?:\/\//, '').replace(/^www\./, '').replace(/\/$/, '').toLowerCase() : '';
                msg.citations.forEach((url, idx) => {
                    let searchResult = null;
                    if (msg.searchResults && Array.isArray(msg.searchResults)) {
                        searchResult = msg.searchResults.find(res => res.url === url);
                        if (!searchResult) {
                            searchResult = msg.searchResults.find(res => normalize(res.url) === normalize(url));
                        }
                    }
                    refs[idx + 1] = {
                        url: url,
                        title: searchResult?.name || searchResult?.title || url,
                        snippet: searchResult?.snippet || 'No snippet available.'
                    };
                });
                return refs;
            } 
            createTokenInfoElement(u) { /* ... same ... */
                const container = document.createElement('div');
                container.className = 'token-info-icon';
                container.textContent = '?';
                const tooltip = document.createElement('div');
                tooltip.className = 'token-tooltip';
                tooltip.innerHTML = `<strong>Token Usage</strong><br>Input: ${u.prompt_tokens || 0}<br>Output: ${u.completion_tokens || 0}<br>Total: ${u.total_tokens || 0}`;
                container.appendChild(tooltip);
                return container;
            }
            attachReferenceHandlers(el) { /* ... same ... */
                el.querySelectorAll('.reference-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        const refNum = e.target.dataset.ref;
                        const data = this.references[refNum];
                        if (data && data.url) {
                            this.currentReference = data;
                            document.getElementById('referenceTitle').textContent = data.title.length > 50 ? 'Source ['+refNum+']' : data.title;
                            document.getElementById('referenceUrl').textContent = data.url;
                            const snippetEl = document.getElementById('referenceSnippet');
                            if (data.snippet) { snippetEl.textContent = data.snippet; snippetEl.classList.remove('hidden'); } else { snippetEl.classList.add('hidden'); }
                            this.referencePopup.classList.remove('hidden');
                        } else { this.showStatus('Reference data not found', 'warning'); }
                    });
                });
            }
            processHighcharts(el) { /* ... */ }
            processTables(container) { /* ... same ... */
                container.querySelectorAll('table').forEach((table, idx) => {
                    if(table.parentNode.classList.contains('table-responsive')) return;
                    const wrap = document.createElement('div'); wrap.className = 'table-responsive';
                    const actions = document.createElement('div'); actions.className = 'table-actions';
                    actions.innerHTML = `<button class="btn btn--secondary btn--sm" onclick="window.chatApp.copyTable(this)">üìã Copy</button><button class="btn btn--secondary btn--sm" onclick="window.exportTable(this)">‚Üó Export</button>`;
                    table.parentNode.insertBefore(wrap, table);
                    wrap.append(actions, table);
                });
            }
            copyTable(btn) { /* ... same ... */
                const range = document.createRange(); range.selectNode(btn.closest('.table-responsive').querySelector('table'));
                window.getSelection().removeAllRanges(); window.getSelection().addRange(range);
                document.execCommand('copy'); window.getSelection().removeAllRanges();
                this.showStatus('Table copied', 'success');
            }
            openTool(path) { /* ... same ... */
                if (path.startsWith('http')) { window.open(path, '_blank'); } else {
                    this.storageManager.readFile(path).then(content => {
                        this.uploadedTextContext = content;
                        this.uploadedFileName = path.split('/').pop();
                        const preview = document.getElementById('imagePreview');
                        preview.classList.remove('hidden');
                        preview.innerHTML = `<span class="file-preview-icon">üõ†Ô∏è</span> <span>${this.uploadedFileName} (Local Tool)</span><span class="remove-image-btn" onclick="window.chatApp.removeImagePreview()">√ó</span>`;
                        this.updateTokenEstimate();
                        this.togglePopup('tools'); 
                        this.showStatus('File Loaded from Workspace', 'success');
                    }).catch(err => { console.error(err); this.showStatus('Failed to read file: ' + err.message, 'error'); });
                }
            }
            
            async deleteChat(id) { 
                await this.storageManager.deleteChat(id);
                delete this.savedChats[id]; 
                this.renderChatHistory(); 
                this.showStatus('Chat Deleted', 'info');
            }
            
            async loadChat(id) { 
                const fullChat = await this.storageManager.getChat(id);
                if (fullChat) {
                    this.sessions[id] = { id, name: fullChat.name, messages: fullChat.messages, references: fullChat.references }; 
                    this.switchSession(id); 
                } else {
                    this.showStatus('Error loading chat', 'error');
                }
                this.togglePopup('history'); 
            }
            
            deleteTool(id) { this.localTools = this.localTools.filter(t=>t.id!==id); localStorage.setItem('localTools', JSON.stringify(this.localTools)); this.renderToolsList(); }
            addTool() { /* ... same ... */
                const name = document.getElementById('toolNameInput').value; const path = document.getElementById('toolPathInput').value;
                if(name && path) { this.localTools.push({ id:Date.now(), name, path }); localStorage.setItem('localTools', JSON.stringify(this.localTools)); this.renderToolsList(); }
            }
            exportData() { /* Removed Bulk Export */ }
            
            async exportSingleChat(id) {
                const chat = await this.storageManager.getChat(id);
                if (!chat) { this.showStatus('Chat not found', 'error'); return; }
                const data = { savedChats: { [id]: chat } };
                const blob = new Blob([JSON.stringify(data, null, 2)], {type : 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = `${chat.name.replace(/[^a-z0-9]/gi, '_')}.json`; a.click();
            }
            
            importSingleChat(e) {
                const files = e.target.files;
                if (!files || files.length === 0) return;
                
                let processedCount = 0;
                const total = files.length;

                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            if(data.savedChats) { 
                                for(const k in data.savedChats) {
                                    await this.storageManager.saveChat(data.savedChats[k]);
                                }
                            }
                        } catch(err) { 
                            console.error("Import error for file " + file.name, err);
                        } finally {
                            processedCount++;
                            if(processedCount === total) {
                                await this.initData(); // Reload metadata
                                this.renderChatHistory();
                                this.showStatus(`Imported ${total} file(s)`, 'success');
                                e.target.value = ''; // Reset input
                            }
                        }
                    };
                    reader.readAsText(file);
                });
            }
            
            saveApiKeys() { this.apiKeys.perplexity = document.getElementById('perplexityApiKey').value; this.apiKeys.moonshot = document.getElementById('moonshotApiKey').value; localStorage.setItem('perplexity_api_key', this.apiKeys.perplexity); localStorage.setItem('moonshot_api_key', this.apiKeys.moonshot); this.togglePopup('apiKey'); this.showStatus('Keys saved', 'success'); }
            toggleApiKeysVisibility() { const p = document.getElementById('perplexityApiKey'); p.type = p.type==='password'?'text':'password'; document.getElementById('moonshotApiKey').type = p.type; }
            processHighcharts(el) { /* ... */ }
            handleTextSelection(e) { /* ... same ... */
                const sel = window.getSelection();
                if(sel.toString().trim() && this.feedbackMode) {
                    const r = sel.getRangeAt(0).getBoundingClientRect();
                    this.selectionTooltip.style.top = (window.scrollY + r.top - 40) + 'px';
                    this.selectionTooltip.style.left = (window.scrollX + r.left) + 'px';
                    this.selectionTooltip.classList.remove('hidden');
                    this.currentSelectionText = sel.toString();
                } else {
                    this.selectionTooltip.classList.add('hidden');
                }
            }
            openRevisionPopup() { this.revisionOriginal.textContent = this.currentSelectionText; this.togglePopup('revision'); this.selectionTooltip.classList.add('hidden'); }
            closeRevisionPopup() { this.revisionPopup.classList.add('hidden'); }
            saveRevision() {
                const rev = document.getElementById('revisionInput').value;
                if(rev) {
                    if(!this.feedbackLoops[this.currentChatId]) this.feedbackLoops[this.currentChatId] = [];
                    this.feedbackLoops[this.currentChatId].push({ original: this.currentSelectionText, revised: rev });
                    localStorage.setItem('feedback_loops', JSON.stringify(this.feedbackLoops));
                    this.closeRevisionPopup();
                    this.showStatus('Feedback Saved', 'success');
                }
            }
            saveCustomPrompt() {
                const n = document.getElementById('customPersonaName').value.trim();
                const p = document.getElementById('customPrompt').value;
                
                if (this.currentPersona === 'customized') {
                    // Update scratchpad
                    this.customPersonaName = n;
                    this.customPrompt = p;
                    localStorage.setItem('customPersonaName', n);
                    localStorage.setItem('customPrompt', p);
                    this.personas.customized.name = n;
                    this.personas.customized.prompt = p;
                    this.updateHeaderStatus();
                    this.showStatus('Scratchpad Updated', 'success');
                } else if (this.savedPersonas[this.currentPersona]) {
                    // Update saved persona
                    this.savedPersonas[this.currentPersona].name = n;
                    this.savedPersonas[this.currentPersona].prompt = p;
                    this.personas[this.currentPersona].name = n;
                    this.personas[this.currentPersona].prompt = p;
                    localStorage.setItem('saved_personas', JSON.stringify(this.savedPersonas));
                    this.renderSavedPersonas();
                    this.updateHeaderStatus(); // Update header in case name changed
                    this.showStatus('Persona Updated', 'success');
                } else {
                    this.showStatus('Cannot edit standard persona. Save as New.', 'warning');
                }
            }
            updateMaxTokens(v) { this.maxTokens = parseInt(v); this.maxTokensValue.textContent = v; localStorage.setItem('maxTokens', v); }
            enableMessageEditing(index) { 
                const msg = this.messages[index];
                const msgEl = this.messagesContainer.children[index];
                if (!msgEl) return;
                const contentEl = msgEl.querySelector('.message-content');
                if (contentEl.querySelector('.msg-edit-textarea')) return; 
                const currentText = msg.content;
                const originalHTML = contentEl.innerHTML;
                contentEl.innerHTML = '';
                const editArea = document.createElement('div'); editArea.className = 'msg-edit-area';
                const textarea = document.createElement('textarea'); textarea.className = 'msg-edit-textarea'; textarea.value = currentText;
                const controls = document.createElement('div'); controls.className = 'msg-edit-controls';
                const saveBtn = document.createElement('button'); saveBtn.className = 'btn btn--primary btn--sm'; saveBtn.textContent = 'Save & Regenerate';
                
                saveBtn.onclick = async () => {
                    const newText = textarea.value.trim();
                    if (newText) {
                        // FIX: Ensure API Key is present before regenerating
                        if (!this.apiKeys[this.currentAPI]) { this.showStatus('No API Key', 'error'); this.setLoading(false); return; }

                        this.messages[index].content = newText;
                        this.messages = this.messages.slice(0, index + 1);
                        this.renderMessages(); 
                        this.setLoading(true);
                        
                        // FIX: Initialize AbortController before API call
                        this.abortController = new AbortController();

                        try {
                            if (this.streamMode) { 
                                await this.streamResponse(null, null); 
                            } else {
                                const res = await this.callAPI(null, null);
                                this.messages.push({ 
                                    role: 'assistant', 
                                    content: res.content, 
                                    timestamp: new Date(), 
                                    tokenUsage: res.tokenUsage, 
                                    searchResults: res.searchResults, 
                                    citations: res.citations 
                                });
                                this.renderMessages(); 
                                await this.autoSaveChat();
                            }
                        } catch (e) {
                            this.showStatus('Error: ' + e.message, 'error');
                        } finally {
                            this.setLoading(false);
                            // Clean up controller
                            this.abortController = null;
                        }
                    }
                };
                const cancelBtn = document.createElement('button'); cancelBtn.className = 'btn btn--secondary btn--sm'; cancelBtn.textContent = 'Cancel';
                cancelBtn.onclick = () => { contentEl.innerHTML = originalHTML; };
                controls.append(cancelBtn, saveBtn); editArea.append(textarea, controls); contentEl.appendChild(editArea);
            }
            handleOutsideClick(e) { 
                if(e.target.classList.contains('popup')) e.target.classList.add('hidden'); 
            }
            copyReference() { navigator.clipboard.writeText(document.getElementById('referenceUrl').textContent); }
            openReference() { window.open(document.getElementById('referenceUrl').textContent, '_blank'); }
            
            async autoSaveChat() { 
                const chatObj = { id: this.currentChatId, name: this.sessions[this.currentChatId].name, messages: this.messages, references: this.references, timestamp: Date.now() };
                try {
                    await this.storageManager.saveChat(chatObj);
                    // Update local metadata cache
                    this.savedChats[this.currentChatId] = { id: chatObj.id, name: chatObj.name, timestamp: chatObj.timestamp };
                    
                    // Visual confirmation (optional, subtle)
                    const saveStatus = document.getElementById('saveStatus');
                    if(saveStatus) {
                        saveStatus.textContent = 'Saved';
                        saveStatus.style.opacity = '1';
                        setTimeout(() => saveStatus.style.opacity = '0', 2000);
                    }
                } catch (e) {
                    console.error("AutoSave Failed:", e);
                    if (e && (e.name === 'QuotaExceededError' || e.code === 22)) {
                        this.showStatus('Storage Full! Delete old chats.', 'error');
                    } else {
                        this.showStatus('Save Failed (Check Console)', 'error');
                    }
                }
            }
            
            async saveCurrentChat() {
                const name = document.getElementById('chatNameInput').value || this.sessions[this.currentChatId].name;
                this.sessions[this.currentChatId].name = name;
                await this.autoSaveChat();
                this.renderChatHistory(); 
                this.showStatus('Chat Saved', 'success');
            }
            
            copyMessage(text) { 
                let contentToCopy = text;
                if (!this.showReferences) {
                    contentToCopy = contentToCopy.replace(/\[\d+\]/g, '');
                }
                navigator.clipboard.writeText(contentToCopy).then(() => this.showStatus('Copied', 'success'));
            }
            
            exportPersonas() {
                const data = this.savedPersonas;
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'personas_backup.json'; a.click();
            }
            
            importPersonas(e) {
                const file = e.target.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        Object.assign(this.savedPersonas, data);
                        Object.assign(this.personas, data); // update active memory
                        localStorage.setItem('saved_personas', JSON.stringify(this.savedPersonas));
                        this.renderSavedPersonas();
                        this.showStatus('Personas Imported', 'success');
                    } catch(err) { this.showStatus('Invalid File', 'error'); }
                };
                reader.readAsText(file);
            }
        }

        /* ... existing exports ... */
        window.exportTable = function(btn) {
            const table = btn.closest('.table-responsive').querySelector('table');
            const win = window.open('', '_blank');
            if(!win) return;
            win.document.title = "Export Table";
            const tableHtml = table.outerHTML;
            const style = `body { font-family: sans-serif; padding: 20px; text-align: center; } table { border-collapse: collapse; width: 100%; margin: 20px 0; } th, td { border: 1px solid #ddd; padding: 8px; text-align: left; } th { background: #f2f2f2; } .btn-group { margin-bottom: 20px; } .btn { padding: 10px 20px; margin: 0 5px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 14px; } .btn:hover { background: #0056b3; }`;
            win.document.write(`<html><head><style>${style}</style><script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"><\/script></head><body><div class="btn-group"><button class="btn" onclick="exportToCSV()">Download CSV</button><button class="btn" onclick="exportToExcel()">Download Excel</button><button class="btn" onclick="exportToJSON()">Download JSON</button></div><div id="tableContainer">${tableHtml}</div><script>function exportToCSV() { if(typeof XLSX === 'undefined') { alert('Library loading... try again in a second.'); return; } const table = document.querySelector("table"); const wb = XLSX.utils.table_to_book(table, {sheet: "Sheet1"}); XLSX.writeFile(wb, "table_export.csv"); } function exportToExcel() { if(typeof XLSX === 'undefined') { alert('Library loading... try again in a second.'); return; } const table = document.querySelector("table"); const wb = XLSX.utils.table_to_book(table, {sheet: "Sheet1"}); XLSX.writeFile(wb, "table_export.xlsx"); } function exportToJSON() { if(typeof XLSX === 'undefined') { alert('Library loading... try again in a second.'); return; } const table = document.querySelector("table"); const wb = XLSX.utils.table_to_book(table, {sheet: "Sheet1"}); const ws = wb.Sheets["Sheet1"]; const data = XLSX.utils.sheet_to_json(ws); const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"}); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = "table_export.json"; a.click(); }<\/script></body></html>`);
            win.document.close();
        };
        
        window.copyCodeBlock = function(id, btn) {
            const txt = document.getElementById(id).textContent;
            navigator.clipboard.writeText(txt).then(() => {
                const originalText = btn.textContent;
                btn.textContent = '‚úî OK';
                btn.classList.add('success');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('success');
                }, 2000);
            });
        };

        document.addEventListener('DOMContentLoaded', () => {
            window.chatApp = new MultiAPIChat();
        });
    </script>
</body>
</html>